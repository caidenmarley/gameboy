Breakpoint 1 at 0x7cb5: file /home/caidenmarley/gameboy/main.cpp, line 21.
Starting program: /home/caidenmarley/gameboy/build/gameboy ../roms/pokemon-red.gb
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".

Breakpoint 1, main (argc=2, argv=0x7fffffffd6e8) at /home/caidenmarley/gameboy/main.cpp:21
21	int main(int argc, char* argv[]){
23	    if (argc < 2) {
28	    if (SDL_Init(SDL_INIT_VIDEO | SDL_INIT_TIMER) != 0) {
[New Thread 0x7ffff6c8e640 (LWP 19198)]
[New Thread 0x7fffeaabe640 (LWP 19200)]
[New Thread 0x7fffea2bd640 (LWP 19201)]
[New Thread 0x7fffe9abc640 (LWP 19202)]
[New Thread 0x7fffe92bb640 (LWP 19203)]
[New Thread 0x7fffe8a3a640 (LWP 19204)]
[New Thread 0x7fffd3fff640 (LWP 19205)]
[Thread 0x7fffd3fff640 (LWP 19205) exited]
[Thread 0x7fffe8a3a640 (LWP 19204) exited]
[New Thread 0x7fffe8a3a640 (LWP 19206)]
[New Thread 0x7fffd3fff640 (LWP 19207)]
[Thread 0x7fffd3fff640 (LWP 19207) exited]
[Thread 0x7fffe8a3a640 (LWP 19206) exited]
33	    SDL_GL_SetAttribute(SDL_GL_CONTEXT_FLAGS, 0);
Breakpoint 2 at 0x55555555c323: file /home/caidenmarley/gameboy/main.cpp, line 122.
Starting program: /home/caidenmarley/gameboy/build/gameboy ../roms/pokemon-red.gb
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
[New Thread 0x7ffff6c8e640 (LWP 19353)]
[New Thread 0x7fffeaabe640 (LWP 19355)]
[New Thread 0x7fffea2bd640 (LWP 19356)]
[New Thread 0x7fffe9abc640 (LWP 19357)]
[New Thread 0x7fffe92bb640 (LWP 19358)]
[New Thread 0x7fffe8a3a640 (LWP 19359)]
[New Thread 0x7fffd3fff640 (LWP 19360)]
[Thread 0x7fffd3fff640 (LWP 19360) exited]
[New Thread 0x7fffe8a3a640 (LWP 19361)]
[Thread 0x7fffe8a3a640 (LWP 19359) exited]
[New Thread 0x7fffd3fff640 (LWP 19362)]
[Thread 0x7fffd3fff640 (LWP 19362) exited]
[Thread 0x7fffe8a3a640 (LWP 19361) exited]
[New Thread 0x7fffe8a3a640 (LWP 19364)]
[New Thread 0x7fffd3fff640 (LWP 19365)]
[Thread 0x7fffd3fff640 (LWP 19365) exited]
[Thread 0x7fffe8a3a640 (LWP 19364) exited]
[New Thread 0x7fffe8a3a640 (LWP 19366)]
[New Thread 0x7fffd3fff640 (LWP 19367)]

Thread 1 "gameboy" hit Breakpoint 2, main (argc=2, argv=0x7fffffffd6e8) at /home/caidenmarley/gameboy/main.cpp:122
122	        while (!bus.ppu.isFrameReady()) {
PPU::isFrameReady (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:46
46	        return frameReady;
47	    }
main (argc=2, argv=0x7fffffffd6e8) at /home/caidenmarley/gameboy/main.cpp:122
122	        while (!bus.ppu.isFrameReady()) {
123	            int m = cpu.step();
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:10
10	    if(imeEnabledNextStep){
16	    if(stopped){
26	    if(halted){
35	    uint8_t ieaValue = bus.read(INTERRUPT_ENABLE_ADDRESS);
Bus::read (this=0x7fffffff3910, address=65535) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::read (this=0x7fffffff3910, address=65535) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
22	    if(address < 0x8000){
25	    }else if(address < 0xA000){
28	    }else if(address < 0xC000){
31	    }else if(address < 0xE000){
34	    }else if(address < 0xFE00){
37	    }else if(address < 0xFEA0){
40	    }else if(address < 0xFF00){
43	    }else if(address == 0xFF00){
63	    }else if(address < 0xFF04){
66	    }else if(address < 0xFF08){
69	    }else if(address >= 0xFF40 && address <= 0xFF4B){
72	    }else if(address < 0xFF80){
75	    }else if(address < 0xFFFF){
80	        return ieReg;
82	}
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:36
36	    uint8_t ifaValue = bus.read(INTERRUPT_FLAG_ADDRESS);
Bus::read (this=0x7fffffff3910, address=65295) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::read (this=0x7fffffff3910, address=65295) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
22	    if(address < 0x8000){
25	    }else if(address < 0xA000){
28	    }else if(address < 0xC000){
31	    }else if(address < 0xE000){
34	    }else if(address < 0xFE00){
37	    }else if(address < 0xFEA0){
40	    }else if(address < 0xFF00){
43	    }else if(address == 0xFF00){
63	    }else if(address < 0xFF04){
66	    }else if(address < 0xFF08){
69	    }else if(address >= 0xFF40 && address <= 0xFF4B){
72	    }else if(address < 0xFF80){
74	        return ioRegs[address - 0xFF00];
82	}
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:37
37	    uint8_t interruptRequest = ieaValue & ifaValue;
38	    if(IME && interruptRequest){
57	    uint8_t opcode = bus.read(PC++);
Bus::read (this=0x7fffffff3910, address=256) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::read (this=0x7fffffff3910, address=256) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
22	    if(address < 0x8000){
24	        return cart.readByte(address);
Cartridge::readByte (this=0x7fffffff3860, address=256) at /home/caidenmarley/gameboy/src/cartridge.cpp:118
118	    if(isMbc2){
135	    if(isMbc1){
159	    if(address < 0x8000){
160	        return romData.at(address);
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=256) at /usr/include/c++/11/bits/stl_vector.h:1094
1094		_M_range_check(__n);
std::vector<unsigned char, std::allocator<unsigned char> >::_M_range_check (this=0x7fffffff38d0, __n=256) at /usr/include/c++/11/bits/stl_vector.h:1072
1072		if (__n >= this->size())
std::vector<unsigned char, std::allocator<unsigned char> >::size (this=0x7fffffff38d0) at /usr/include/c++/11/bits/stl_vector.h:919
919	      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
std::vector<unsigned char, std::allocator<unsigned char> >::_M_range_check (this=0x7fffffff38d0, __n=256) at /usr/include/c++/11/bits/stl_vector.h:1072
1072		if (__n >= this->size())
1077	      }
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=256) at /usr/include/c++/11/bits/stl_vector.h:1095
1095		return (*this)[__n];
std::vector<unsigned char, std::allocator<unsigned char> >::operator[] (this=0x7fffffff38d0, __n=256) at /usr/include/c++/11/bits/stl_vector.h:1046
1046		return *(this->_M_impl._M_start + __n);
1047	      }
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=256) at /usr/include/c++/11/bits/stl_vector.h:1096
1096	      }
Cartridge::readByte (this=0x7fffffff3860, address=256) at /home/caidenmarley/gameboy/src/cartridge.cpp:160
160	        return romData.at(address);
168	}
Bus::read (this=0x7fffffff3910, address=256) at /home/caidenmarley/gameboy/src/bus.cpp:24
24	        return cart.readByte(address);
82	}
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:58
58	    return decodeAndExecute(*this, bus, opcode);
decodeAndExecute (cpu=..., bus=..., opcode=0 '\000') at /home/caidenmarley/gameboy/include/instructions.h:93
93	    switch(opcode){
95	            return 1;
1886	}
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:58
58	    return decodeAndExecute(*this, bus, opcode);
59	}
main (argc=2, argv=0x7fffffffd6e8) at /home/caidenmarley/gameboy/main.cpp:124
124	            bus.step(m * 4, cpu);
Bus::step (this=0x7fffffff3910, tStates=4, cpu=...) at /home/caidenmarley/gameboy/src/bus.cpp:140
140	    timer.step(tStates, cpu);
Timer::step (this=0x7fffffffb4a0, tStates=4, cpu=...) at /home/caidenmarley/gameboy/src/timer.cpp:8
8	    divCounter += tStates;
9	    while(divCounter >= 256){
15	    if(TAC & 0x04){
30	}
Bus::step (this=0x7fffffff3910, tStates=4, cpu=...) at /home/caidenmarley/gameboy/src/bus.cpp:141
141	    ppu.step(tStates, cpu);
PPU::step (this=0x7fffffff3910, tStates=4, cpu=...) at /home/caidenmarley/gameboy/src/ppu.cpp:17
17	void PPU::step(int tStates, CPU& cpu){
18	    stepDma(tStates);
PPU::stepDma (this=0x7fffffff3910, cycles=4) at /home/caidenmarley/gameboy/include/ppu.h:151
151	        if(!oamDmaActive) return;
156	    }
PPU::step (this=0x7fffffff3910, tStates=4, cpu=...) at /home/caidenmarley/gameboy/src/ppu.cpp:20
20	    if(!(LCDC & 0x80)){
24	    dotCounter += tStates;
27	        uint8_t mode = STAT & 0x03;
28	        int needed = 0;
30	        switch(mode){
46	            case 1: needed = 4560; break;
50	        if (dotCounter < needed){
51	            break;
142	}
Bus::step (this=0x7fffffff3910, tStates=4, cpu=...) at /home/caidenmarley/gameboy/src/bus.cpp:143
143	}
main (argc=2, argv=0x7fffffffd6e8) at /home/caidenmarley/gameboy/main.cpp:122
122	        while (!bus.ppu.isFrameReady()) {
PPU::isFrameReady (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:46
46	        return frameReady;
47	    }
main (argc=2, argv=0x7fffffffd6e8) at /home/caidenmarley/gameboy/main.cpp:122
122	        while (!bus.ppu.isFrameReady()) {
123	            int m = cpu.step();
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:10
10	    if(imeEnabledNextStep){
16	    if(stopped){
26	    if(halted){
35	    uint8_t ieaValue = bus.read(INTERRUPT_ENABLE_ADDRESS);
Bus::read (this=0x7fffffff3910, address=65535) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::read (this=0x7fffffff3910, address=65535) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
22	    if(address < 0x8000){
25	    }else if(address < 0xA000){
28	    }else if(address < 0xC000){
31	    }else if(address < 0xE000){
34	    }else if(address < 0xFE00){
37	    }else if(address < 0xFEA0){
40	    }else if(address < 0xFF00){
43	    }else if(address == 0xFF00){
63	    }else if(address < 0xFF04){
66	    }else if(address < 0xFF08){
69	    }else if(address >= 0xFF40 && address <= 0xFF4B){
72	    }else if(address < 0xFF80){
75	    }else if(address < 0xFFFF){
80	        return ieReg;
82	}
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:36
36	    uint8_t ifaValue = bus.read(INTERRUPT_FLAG_ADDRESS);
Bus::read (this=0x7fffffff3910, address=65295) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::read (this=0x7fffffff3910, address=65295) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
22	    if(address < 0x8000){
25	    }else if(address < 0xA000){
28	    }else if(address < 0xC000){
31	    }else if(address < 0xE000){
34	    }else if(address < 0xFE00){
37	    }else if(address < 0xFEA0){
40	    }else if(address < 0xFF00){
43	    }else if(address == 0xFF00){
63	    }else if(address < 0xFF04){
66	    }else if(address < 0xFF08){
69	    }else if(address >= 0xFF40 && address <= 0xFF4B){
72	    }else if(address < 0xFF80){
74	        return ioRegs[address - 0xFF00];
82	}
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:37
37	    uint8_t interruptRequest = ieaValue & ifaValue;
38	    if(IME && interruptRequest){
57	    uint8_t opcode = bus.read(PC++);
Bus::read (this=0x7fffffff3910, address=257) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::read (this=0x7fffffff3910, address=257) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
22	    if(address < 0x8000){
24	        return cart.readByte(address);
Cartridge::readByte (this=0x7fffffff3860, address=257) at /home/caidenmarley/gameboy/src/cartridge.cpp:118
118	    if(isMbc2){
135	    if(isMbc1){
159	    if(address < 0x8000){
160	        return romData.at(address);
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=257) at /usr/include/c++/11/bits/stl_vector.h:1094
1094		_M_range_check(__n);
std::vector<unsigned char, std::allocator<unsigned char> >::_M_range_check (this=0x7fffffff38d0, __n=257) at /usr/include/c++/11/bits/stl_vector.h:1072
1072		if (__n >= this->size())
std::vector<unsigned char, std::allocator<unsigned char> >::size (this=0x7fffffff38d0) at /usr/include/c++/11/bits/stl_vector.h:919
919	      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
std::vector<unsigned char, std::allocator<unsigned char> >::_M_range_check (this=0x7fffffff38d0, __n=257) at /usr/include/c++/11/bits/stl_vector.h:1072
1072		if (__n >= this->size())
1077	      }
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=257) at /usr/include/c++/11/bits/stl_vector.h:1095
1095		return (*this)[__n];
std::vector<unsigned char, std::allocator<unsigned char> >::operator[] (this=0x7fffffff38d0, __n=257) at /usr/include/c++/11/bits/stl_vector.h:1046
1046		return *(this->_M_impl._M_start + __n);
1047	      }
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=257) at /usr/include/c++/11/bits/stl_vector.h:1096
1096	      }
Cartridge::readByte (this=0x7fffffff3860, address=257) at /home/caidenmarley/gameboy/src/cartridge.cpp:160
160	        return romData.at(address);
168	}
Bus::read (this=0x7fffffff3910, address=257) at /home/caidenmarley/gameboy/src/bus.cpp:24
24	        return cart.readByte(address);
82	}
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:58
58	    return decodeAndExecute(*this, bus, opcode);
decodeAndExecute (cpu=..., bus=..., opcode=195 '\303') at /home/caidenmarley/gameboy/include/instructions.h:93
93	    switch(opcode){
1468	                uint8_t low = bus.read(cpu.PC++);
Bus::read (this=0x7fffffff3910, address=258) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::read (this=0x7fffffff3910, address=258) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
22	    if(address < 0x8000){
24	        return cart.readByte(address);
Cartridge::readByte (this=0x7fffffff3860, address=258) at /home/caidenmarley/gameboy/src/cartridge.cpp:118
118	    if(isMbc2){
135	    if(isMbc1){
159	    if(address < 0x8000){
160	        return romData.at(address);
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=258) at /usr/include/c++/11/bits/stl_vector.h:1094
1094		_M_range_check(__n);
std::vector<unsigned char, std::allocator<unsigned char> >::_M_range_check (this=0x7fffffff38d0, __n=258) at /usr/include/c++/11/bits/stl_vector.h:1072
1072		if (__n >= this->size())
std::vector<unsigned char, std::allocator<unsigned char> >::size (this=0x7fffffff38d0) at /usr/include/c++/11/bits/stl_vector.h:919
919	      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
std::vector<unsigned char, std::allocator<unsigned char> >::_M_range_check (this=0x7fffffff38d0, __n=258) at /usr/include/c++/11/bits/stl_vector.h:1072
1072		if (__n >= this->size())
1077	      }
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=258) at /usr/include/c++/11/bits/stl_vector.h:1095
1095		return (*this)[__n];
std::vector<unsigned char, std::allocator<unsigned char> >::operator[] (this=0x7fffffff38d0, __n=258) at /usr/include/c++/11/bits/stl_vector.h:1046
1046		return *(this->_M_impl._M_start + __n);
1047	      }
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=258) at /usr/include/c++/11/bits/stl_vector.h:1096
1096	      }
Cartridge::readByte (this=0x7fffffff3860, address=258) at /home/caidenmarley/gameboy/src/cartridge.cpp:160
160	        return romData.at(address);
168	}
Bus::read (this=0x7fffffff3910, address=258) at /home/caidenmarley/gameboy/src/bus.cpp:24
24	        return cart.readByte(address);
82	}
decodeAndExecute (cpu=..., bus=..., opcode=195 '\303') at /home/caidenmarley/gameboy/include/instructions.h:1469
1469	                uint8_t high = bus.read(cpu.PC++);
Bus::read (this=0x7fffffff3910, address=259) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::read (this=0x7fffffff3910, address=259) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
22	    if(address < 0x8000){
24	        return cart.readByte(address);
Cartridge::readByte (this=0x7fffffff3860, address=259) at /home/caidenmarley/gameboy/src/cartridge.cpp:118
118	    if(isMbc2){
135	    if(isMbc1){
159	    if(address < 0x8000){
160	        return romData.at(address);
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=259) at /usr/include/c++/11/bits/stl_vector.h:1094
1094		_M_range_check(__n);
std::vector<unsigned char, std::allocator<unsigned char> >::_M_range_check (this=0x7fffffff38d0, __n=259) at /usr/include/c++/11/bits/stl_vector.h:1072
1072		if (__n >= this->size())
std::vector<unsigned char, std::allocator<unsigned char> >::size (this=0x7fffffff38d0) at /usr/include/c++/11/bits/stl_vector.h:919
919	      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
std::vector<unsigned char, std::allocator<unsigned char> >::_M_range_check (this=0x7fffffff38d0, __n=259) at /usr/include/c++/11/bits/stl_vector.h:1072
1072		if (__n >= this->size())
1077	      }
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=259) at /usr/include/c++/11/bits/stl_vector.h:1095
1095		return (*this)[__n];
std::vector<unsigned char, std::allocator<unsigned char> >::operator[] (this=0x7fffffff38d0, __n=259) at /usr/include/c++/11/bits/stl_vector.h:1046
1046		return *(this->_M_impl._M_start + __n);
1047	      }
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=259) at /usr/include/c++/11/bits/stl_vector.h:1096
1096	      }
Cartridge::readByte (this=0x7fffffff3860, address=259) at /home/caidenmarley/gameboy/src/cartridge.cpp:160
160	        return romData.at(address);
168	}
Bus::read (this=0x7fffffff3910, address=259) at /home/caidenmarley/gameboy/src/bus.cpp:24
24	        return cart.readByte(address);
82	}
decodeAndExecute (cpu=..., bus=..., opcode=195 '\303') at /home/caidenmarley/gameboy/include/instructions.h:1470
1470	                uint16_t result = uint16_t(high << 8) | uint16_t(low);
1471	                cpu.PC = result;
1472	                return 4;
1886	}
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:58
58	    return decodeAndExecute(*this, bus, opcode);
59	}
main (argc=2, argv=0x7fffffffd6e8) at /home/caidenmarley/gameboy/main.cpp:124
124	            bus.step(m * 4, cpu);
Bus::step (this=0x7fffffff3910, tStates=16, cpu=...) at /home/caidenmarley/gameboy/src/bus.cpp:140
140	    timer.step(tStates, cpu);
Timer::step (this=0x7fffffffb4a0, tStates=16, cpu=...) at /home/caidenmarley/gameboy/src/timer.cpp:8
8	    divCounter += tStates;
9	    while(divCounter >= 256){
15	    if(TAC & 0x04){
30	}
Bus::step (this=0x7fffffff3910, tStates=16, cpu=...) at /home/caidenmarley/gameboy/src/bus.cpp:141
141	    ppu.step(tStates, cpu);
PPU::step (this=0x7fffffff3910, tStates=16, cpu=...) at /home/caidenmarley/gameboy/src/ppu.cpp:17
17	void PPU::step(int tStates, CPU& cpu){
18	    stepDma(tStates);
PPU::stepDma (this=0x7fffffff3910, cycles=16) at /home/caidenmarley/gameboy/include/ppu.h:151
151	        if(!oamDmaActive) return;
156	    }
PPU::step (this=0x7fffffff3910, tStates=16, cpu=...) at /home/caidenmarley/gameboy/src/ppu.cpp:20
20	    if(!(LCDC & 0x80)){
24	    dotCounter += tStates;
27	        uint8_t mode = STAT & 0x03;
28	        int needed = 0;
30	        switch(mode){
46	            case 1: needed = 4560; break;
50	        if (dotCounter < needed){
51	            break;
142	}
Bus::step (this=0x7fffffff3910, tStates=16, cpu=...) at /home/caidenmarley/gameboy/src/bus.cpp:143
143	}
main (argc=2, argv=0x7fffffffd6e8) at /home/caidenmarley/gameboy/main.cpp:122
122	        while (!bus.ppu.isFrameReady()) {
PPU::isFrameReady (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:46
46	        return frameReady;
47	    }
main (argc=2, argv=0x7fffffffd6e8) at /home/caidenmarley/gameboy/main.cpp:122
122	        while (!bus.ppu.isFrameReady()) {
$1 = 0x91
$2 = 0x91
$3 = 0x91
$4 = 0x91
123	            int m = cpu.step();
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:10
10	    if(imeEnabledNextStep){
16	    if(stopped){
26	    if(halted){
35	    uint8_t ieaValue = bus.read(INTERRUPT_ENABLE_ADDRESS);
Bus::read (this=0x7fffffff3910, address=65535) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::read (this=0x7fffffff3910, address=65535) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
22	    if(address < 0x8000){
25	    }else if(address < 0xA000){
28	    }else if(address < 0xC000){
31	    }else if(address < 0xE000){
34	    }else if(address < 0xFE00){
37	    }else if(address < 0xFEA0){
40	    }else if(address < 0xFF00){
43	    }else if(address == 0xFF00){
63	    }else if(address < 0xFF04){
66	    }else if(address < 0xFF08){
69	    }else if(address >= 0xFF40 && address <= 0xFF4B){
72	    }else if(address < 0xFF80){
75	    }else if(address < 0xFFFF){
80	        return ieReg;
82	}
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:36
36	    uint8_t ifaValue = bus.read(INTERRUPT_FLAG_ADDRESS);
Bus::read (this=0x7fffffff3910, address=65295) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::read (this=0x7fffffff3910, address=65295) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
22	    if(address < 0x8000){
25	    }else if(address < 0xA000){
28	    }else if(address < 0xC000){
31	    }else if(address < 0xE000){
34	    }else if(address < 0xFE00){
37	    }else if(address < 0xFEA0){
40	    }else if(address < 0xFF00){
43	    }else if(address == 0xFF00){
63	    }else if(address < 0xFF04){
66	    }else if(address < 0xFF08){
69	    }else if(address >= 0xFF40 && address <= 0xFF4B){
72	    }else if(address < 0xFF80){
74	        return ioRegs[address - 0xFF00];
82	}
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:37
37	    uint8_t interruptRequest = ieaValue & ifaValue;
38	    if(IME && interruptRequest){
57	    uint8_t opcode = bus.read(PC++);
Bus::read (this=0x7fffffff3910, address=336) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::read (this=0x7fffffff3910, address=336) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
22	    if(address < 0x8000){
24	        return cart.readByte(address);
Cartridge::readByte (this=0x7fffffff3860, address=336) at /home/caidenmarley/gameboy/src/cartridge.cpp:118
118	    if(isMbc2){
135	    if(isMbc1){
159	    if(address < 0x8000){
160	        return romData.at(address);
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=336) at /usr/include/c++/11/bits/stl_vector.h:1094
1094		_M_range_check(__n);
std::vector<unsigned char, std::allocator<unsigned char> >::_M_range_check (this=0x7fffffff38d0, __n=336) at /usr/include/c++/11/bits/stl_vector.h:1072
1072		if (__n >= this->size())
std::vector<unsigned char, std::allocator<unsigned char> >::size (this=0x7fffffff38d0) at /usr/include/c++/11/bits/stl_vector.h:919
919	      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
std::vector<unsigned char, std::allocator<unsigned char> >::_M_range_check (this=0x7fffffff38d0, __n=336) at /usr/include/c++/11/bits/stl_vector.h:1072
1072		if (__n >= this->size())
1077	      }
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=336) at /usr/include/c++/11/bits/stl_vector.h:1095
1095		return (*this)[__n];
std::vector<unsigned char, std::allocator<unsigned char> >::operator[] (this=0x7fffffff38d0, __n=336) at /usr/include/c++/11/bits/stl_vector.h:1046
1046		return *(this->_M_impl._M_start + __n);
1047	      }
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=336) at /usr/include/c++/11/bits/stl_vector.h:1096
1096	      }
Cartridge::readByte (this=0x7fffffff3860, address=336) at /home/caidenmarley/gameboy/src/cartridge.cpp:160
160	        return romData.at(address);
168	}
Bus::read (this=0x7fffffff3910, address=336) at /home/caidenmarley/gameboy/src/bus.cpp:24
24	        return cart.readByte(address);
82	}
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:58
58	    return decodeAndExecute(*this, bus, opcode);
decodeAndExecute (cpu=..., bus=..., opcode=254 '\376') at /home/caidenmarley/gameboy/include/instructions.h:93
93	    switch(opcode){
1872	                compareWithA(bus.read(cpu.PC++), cpu);
Bus::read (this=0x7fffffff3910, address=337) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::read (this=0x7fffffff3910, address=337) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
22	    if(address < 0x8000){
24	        return cart.readByte(address);
Cartridge::readByte (this=0x7fffffff3860, address=337) at /home/caidenmarley/gameboy/src/cartridge.cpp:118
118	    if(isMbc2){
135	    if(isMbc1){
159	    if(address < 0x8000){
160	        return romData.at(address);
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=337) at /usr/include/c++/11/bits/stl_vector.h:1094
1094		_M_range_check(__n);
std::vector<unsigned char, std::allocator<unsigned char> >::_M_range_check (this=0x7fffffff38d0, __n=337) at /usr/include/c++/11/bits/stl_vector.h:1072
1072		if (__n >= this->size())
std::vector<unsigned char, std::allocator<unsigned char> >::size (this=0x7fffffff38d0) at /usr/include/c++/11/bits/stl_vector.h:919
919	      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
std::vector<unsigned char, std::allocator<unsigned char> >::_M_range_check (this=0x7fffffff38d0, __n=337) at /usr/include/c++/11/bits/stl_vector.h:1072
1072		if (__n >= this->size())
1077	      }
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=337) at /usr/include/c++/11/bits/stl_vector.h:1095
1095		return (*this)[__n];
std::vector<unsigned char, std::allocator<unsigned char> >::operator[] (this=0x7fffffff38d0, __n=337) at /usr/include/c++/11/bits/stl_vector.h:1046
1046		return *(this->_M_impl._M_start + __n);
1047	      }
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=337) at /usr/include/c++/11/bits/stl_vector.h:1096
1096	      }
Cartridge::readByte (this=0x7fffffff3860, address=337) at /home/caidenmarley/gameboy/src/cartridge.cpp:160
160	        return romData.at(address);
168	}
Bus::read (this=0x7fffffff3910, address=337) at /home/caidenmarley/gameboy/src/bus.cpp:24
24	        return cart.readByte(address);
82	}
decodeAndExecute (cpu=..., bus=..., opcode=254 '\376') at /home/caidenmarley/gameboy/include/instructions.h:1872
1872	                compareWithA(bus.read(cpu.PC++), cpu);
compareWithA (value=17 '\021', cpu=...) at /home/caidenmarley/gameboy/include/instructions.h:72
72	    uint16_t result = cpu.A - value;
73	    cpu.setFlag(cpu.zF, (result & 0xFF)==0);
CPU::setFlag (this=0x7fffffff37c0, isolatingBit=128 '\200', on=false) at /home/caidenmarley/gameboy/include/cpu.h:64
64	        if(on){
67	            F &= ~isolatingBit;
69	    }
compareWithA (value=17 '\021', cpu=...) at /home/caidenmarley/gameboy/include/instructions.h:74
74	    cpu.setFlag(cpu.nF, true);
CPU::setFlag (this=0x7fffffff37c0, isolatingBit=64 '@', on=true) at /home/caidenmarley/gameboy/include/cpu.h:64
64	        if(on){
65	            F |= isolatingBit;
69	    }
compareWithA (value=17 '\021', cpu=...) at /home/caidenmarley/gameboy/include/instructions.h:75
75	    cpu.setFlag(cpu.hF, (cpu.A & 0x0F) < (value & 0x0F));
CPU::setFlag (this=0x7fffffff37c0, isolatingBit=32 ' ', on=false) at /home/caidenmarley/gameboy/include/cpu.h:64
64	        if(on){
67	            F &= ~isolatingBit;
69	    }
compareWithA (value=17 '\021', cpu=...) at /home/caidenmarley/gameboy/include/instructions.h:76
76	    cpu.setFlag(cpu.cF, cpu.A < value);
CPU::setFlag (this=0x7fffffff37c0, isolatingBit=16 '\020', on=true) at /home/caidenmarley/gameboy/include/cpu.h:64
64	        if(on){
65	            F |= isolatingBit;
69	    }
compareWithA (value=17 '\021', cpu=...) at /home/caidenmarley/gameboy/include/instructions.h:77
77	}
decodeAndExecute (cpu=..., bus=..., opcode=254 '\376') at /home/caidenmarley/gameboy/include/instructions.h:1873
1873	                return 2;
1886	}
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:58
58	    return decodeAndExecute(*this, bus, opcode);
59	}
main (argc=2, argv=0x7fffffffd6e8) at /home/caidenmarley/gameboy/main.cpp:124
124	            bus.step(m * 4, cpu);
Bus::step (this=0x7fffffff3910, tStates=8, cpu=...) at /home/caidenmarley/gameboy/src/bus.cpp:140
140	    timer.step(tStates, cpu);
Timer::step (this=0x7fffffffb4a0, tStates=8, cpu=...) at /home/caidenmarley/gameboy/src/timer.cpp:8
8	    divCounter += tStates;
9	    while(divCounter >= 256){
15	    if(TAC & 0x04){
30	}
Bus::step (this=0x7fffffff3910, tStates=8, cpu=...) at /home/caidenmarley/gameboy/src/bus.cpp:141
141	    ppu.step(tStates, cpu);
PPU::step (this=0x7fffffff3910, tStates=8, cpu=...) at /home/caidenmarley/gameboy/src/ppu.cpp:17
17	void PPU::step(int tStates, CPU& cpu){
18	    stepDma(tStates);
PPU::stepDma (this=0x7fffffff3910, cycles=8) at /home/caidenmarley/gameboy/include/ppu.h:151
151	        if(!oamDmaActive) return;
156	    }
PPU::step (this=0x7fffffff3910, tStates=8, cpu=...) at /home/caidenmarley/gameboy/src/ppu.cpp:20
20	    if(!(LCDC & 0x80)){
24	    dotCounter += tStates;
27	        uint8_t mode = STAT & 0x03;
28	        int needed = 0;
30	        switch(mode){
46	            case 1: needed = 4560; break;
50	        if (dotCounter < needed){
51	            break;
142	}
Bus::step (this=0x7fffffff3910, tStates=8, cpu=...) at /home/caidenmarley/gameboy/src/bus.cpp:143
143	}
main (argc=2, argv=0x7fffffffd6e8) at /home/caidenmarley/gameboy/main.cpp:122
122	        while (!bus.ppu.isFrameReady()) {
PPU::isFrameReady (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:46
46	        return frameReady;
47	    }
main (argc=2, argv=0x7fffffffd6e8) at /home/caidenmarley/gameboy/main.cpp:122
122	        while (!bus.ppu.isFrameReady()) {
123	            int m = cpu.step();
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:10
10	    if(imeEnabledNextStep){
16	    if(stopped){
26	    if(halted){
35	    uint8_t ieaValue = bus.read(INTERRUPT_ENABLE_ADDRESS);
Bus::read (this=0x7fffffff3910, address=65535) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::read (this=0x7fffffff3910, address=65535) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
22	    if(address < 0x8000){
25	    }else if(address < 0xA000){
28	    }else if(address < 0xC000){
31	    }else if(address < 0xE000){
34	    }else if(address < 0xFE00){
37	    }else if(address < 0xFEA0){
40	    }else if(address < 0xFF00){
43	    }else if(address == 0xFF00){
63	    }else if(address < 0xFF04){
66	    }else if(address < 0xFF08){
69	    }else if(address >= 0xFF40 && address <= 0xFF4B){
72	    }else if(address < 0xFF80){
75	    }else if(address < 0xFFFF){
80	        return ieReg;
82	}
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:36
36	    uint8_t ifaValue = bus.read(INTERRUPT_FLAG_ADDRESS);
Bus::read (this=0x7fffffff3910, address=65295) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::read (this=0x7fffffff3910, address=65295) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
22	    if(address < 0x8000){
25	    }else if(address < 0xA000){
28	    }else if(address < 0xC000){
31	    }else if(address < 0xE000){
34	    }else if(address < 0xFE00){
37	    }else if(address < 0xFEA0){
40	    }else if(address < 0xFF00){
43	    }else if(address == 0xFF00){
63	    }else if(address < 0xFF04){
66	    }else if(address < 0xFF08){
69	    }else if(address >= 0xFF40 && address <= 0xFF4B){
72	    }else if(address < 0xFF80){
74	        return ioRegs[address - 0xFF00];
82	}
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:37
37	    uint8_t interruptRequest = ieaValue & ifaValue;
38	    if(IME && interruptRequest){
57	    uint8_t opcode = bus.read(PC++);
Bus::read (this=0x7fffffff3910, address=338) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::read (this=0x7fffffff3910, address=338) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
22	    if(address < 0x8000){
24	        return cart.readByte(address);
Cartridge::readByte (this=0x7fffffff3860, address=338) at /home/caidenmarley/gameboy/src/cartridge.cpp:118
118	    if(isMbc2){
135	    if(isMbc1){
159	    if(address < 0x8000){
160	        return romData.at(address);
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=338) at /usr/include/c++/11/bits/stl_vector.h:1094
1094		_M_range_check(__n);
std::vector<unsigned char, std::allocator<unsigned char> >::_M_range_check (this=0x7fffffff38d0, __n=338) at /usr/include/c++/11/bits/stl_vector.h:1072
1072		if (__n >= this->size())
std::vector<unsigned char, std::allocator<unsigned char> >::size (this=0x7fffffff38d0) at /usr/include/c++/11/bits/stl_vector.h:919
919	      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
std::vector<unsigned char, std::allocator<unsigned char> >::_M_range_check (this=0x7fffffff38d0, __n=338) at /usr/include/c++/11/bits/stl_vector.h:1072
1072		if (__n >= this->size())
1077	      }
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=338) at /usr/include/c++/11/bits/stl_vector.h:1095
1095		return (*this)[__n];
std::vector<unsigned char, std::allocator<unsigned char> >::operator[] (this=0x7fffffff38d0, __n=338) at /usr/include/c++/11/bits/stl_vector.h:1046
1046		return *(this->_M_impl._M_start + __n);
1047	      }
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=338) at /usr/include/c++/11/bits/stl_vector.h:1096
1096	      }
Cartridge::readByte (this=0x7fffffff3860, address=338) at /home/caidenmarley/gameboy/src/cartridge.cpp:160
160	        return romData.at(address);
168	}
Bus::read (this=0x7fffffff3910, address=338) at /home/caidenmarley/gameboy/src/bus.cpp:24
24	        return cart.readByte(address);
82	}
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:58
58	    return decodeAndExecute(*this, bus, opcode);
decodeAndExecute (cpu=..., bus=..., opcode=40 '(') at /home/caidenmarley/gameboy/include/instructions.h:93
93	    switch(opcode){
460	                int8_t offset = int8_t(bus.read(cpu.PC++));
Bus::read (this=0x7fffffff3910, address=339) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::read (this=0x7fffffff3910, address=339) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
22	    if(address < 0x8000){
24	        return cart.readByte(address);
Cartridge::readByte (this=0x7fffffff3860, address=339) at /home/caidenmarley/gameboy/src/cartridge.cpp:118
118	    if(isMbc2){
135	    if(isMbc1){
159	    if(address < 0x8000){
160	        return romData.at(address);
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=339) at /usr/include/c++/11/bits/stl_vector.h:1094
1094		_M_range_check(__n);
std::vector<unsigned char, std::allocator<unsigned char> >::_M_range_check (this=0x7fffffff38d0, __n=339) at /usr/include/c++/11/bits/stl_vector.h:1072
1072		if (__n >= this->size())
std::vector<unsigned char, std::allocator<unsigned char> >::size (this=0x7fffffff38d0) at /usr/include/c++/11/bits/stl_vector.h:919
919	      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
std::vector<unsigned char, std::allocator<unsigned char> >::_M_range_check (this=0x7fffffff38d0, __n=339) at /usr/include/c++/11/bits/stl_vector.h:1072
1072		if (__n >= this->size())
1077	      }
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=339) at /usr/include/c++/11/bits/stl_vector.h:1095
1095		return (*this)[__n];
std::vector<unsigned char, std::allocator<unsigned char> >::operator[] (this=0x7fffffff38d0, __n=339) at /usr/include/c++/11/bits/stl_vector.h:1046
1046		return *(this->_M_impl._M_start + __n);
1047	      }
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=339) at /usr/include/c++/11/bits/stl_vector.h:1096
1096	      }
Cartridge::readByte (this=0x7fffffff3860, address=339) at /home/caidenmarley/gameboy/src/cartridge.cpp:160
160	        return romData.at(address);
168	}
Bus::read (this=0x7fffffff3910, address=339) at /home/caidenmarley/gameboy/src/bus.cpp:24
24	        return cart.readByte(address);
82	}
decodeAndExecute (cpu=..., bus=..., opcode=40 '(') at /home/caidenmarley/gameboy/include/instructions.h:460
460	                int8_t offset = int8_t(bus.read(cpu.PC++));
461	                if(cpu.getFlag(cpu.zF)){
CPU::getFlag (this=0x7fffffff37c0, isolatingBit=128 '\200') at /home/caidenmarley/gameboy/include/cpu.h:72
72	        return (F & isolatingBit) != 0; // if flag bit is 0, expression == 0, so false, else true
73	    }
decodeAndExecute (cpu=..., bus=..., opcode=40 '(') at /home/caidenmarley/gameboy/include/instructions.h:461
461	                if(cpu.getFlag(cpu.zF)){
465	                    return 2;
1886	}
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:58
58	    return decodeAndExecute(*this, bus, opcode);
59	}
main (argc=2, argv=0x7fffffffd6e8) at /home/caidenmarley/gameboy/main.cpp:124
124	            bus.step(m * 4, cpu);
Bus::step (this=0x7fffffff3910, tStates=8, cpu=...) at /home/caidenmarley/gameboy/src/bus.cpp:140
140	    timer.step(tStates, cpu);
Timer::step (this=0x7fffffffb4a0, tStates=8, cpu=...) at /home/caidenmarley/gameboy/src/timer.cpp:8
8	    divCounter += tStates;
9	    while(divCounter >= 256){
15	    if(TAC & 0x04){
30	}
Bus::step (this=0x7fffffff3910, tStates=8, cpu=...) at /home/caidenmarley/gameboy/src/bus.cpp:141
141	    ppu.step(tStates, cpu);
PPU::step (this=0x7fffffff3910, tStates=8, cpu=...) at /home/caidenmarley/gameboy/src/ppu.cpp:17
17	void PPU::step(int tStates, CPU& cpu){
18	    stepDma(tStates);
PPU::stepDma (this=0x7fffffff3910, cycles=8) at /home/caidenmarley/gameboy/include/ppu.h:151
151	        if(!oamDmaActive) return;
156	    }
PPU::step (this=0x7fffffff3910, tStates=8, cpu=...) at /home/caidenmarley/gameboy/src/ppu.cpp:20
20	    if(!(LCDC & 0x80)){
24	    dotCounter += tStates;
27	        uint8_t mode = STAT & 0x03;
28	        int needed = 0;
30	        switch(mode){
46	            case 1: needed = 4560; break;
50	        if (dotCounter < needed){
51	            break;
142	}
Bus::step (this=0x7fffffff3910, tStates=8, cpu=...) at /home/caidenmarley/gameboy/src/bus.cpp:143
143	}
main (argc=2, argv=0x7fffffffd6e8) at /home/caidenmarley/gameboy/main.cpp:122
122	        while (!bus.ppu.isFrameReady()) {
PPU::isFrameReady (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:46
46	        return frameReady;
47	    }
main (argc=2, argv=0x7fffffffd6e8) at /home/caidenmarley/gameboy/main.cpp:122
122	        while (!bus.ppu.isFrameReady()) {
123	            int m = cpu.step();
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:10
10	    if(imeEnabledNextStep){
16	    if(stopped){
26	    if(halted){
35	    uint8_t ieaValue = bus.read(INTERRUPT_ENABLE_ADDRESS);
Bus::read (this=0x7fffffff3910, address=65535) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::read (this=0x7fffffff3910, address=65535) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
22	    if(address < 0x8000){
25	    }else if(address < 0xA000){
28	    }else if(address < 0xC000){
31	    }else if(address < 0xE000){
34	    }else if(address < 0xFE00){
37	    }else if(address < 0xFEA0){
40	    }else if(address < 0xFF00){
43	    }else if(address == 0xFF00){
63	    }else if(address < 0xFF04){
66	    }else if(address < 0xFF08){
69	    }else if(address >= 0xFF40 && address <= 0xFF4B){
72	    }else if(address < 0xFF80){
75	    }else if(address < 0xFFFF){
80	        return ieReg;
82	}
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:36
36	    uint8_t ifaValue = bus.read(INTERRUPT_FLAG_ADDRESS);
Bus::read (this=0x7fffffff3910, address=65295) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::read (this=0x7fffffff3910, address=65295) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
22	    if(address < 0x8000){
25	    }else if(address < 0xA000){
28	    }else if(address < 0xC000){
31	    }else if(address < 0xE000){
34	    }else if(address < 0xFE00){
37	    }else if(address < 0xFEA0){
40	    }else if(address < 0xFF00){
43	    }else if(address == 0xFF00){
63	    }else if(address < 0xFF04){
66	    }else if(address < 0xFF08){
69	    }else if(address >= 0xFF40 && address <= 0xFF4B){
72	    }else if(address < 0xFF80){
74	        return ioRegs[address - 0xFF00];
82	}
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:37
37	    uint8_t interruptRequest = ieaValue & ifaValue;
38	    if(IME && interruptRequest){
57	    uint8_t opcode = bus.read(PC++);
Bus::read (this=0x7fffffff3910, address=340) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::read (this=0x7fffffff3910, address=340) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
22	    if(address < 0x8000){
24	        return cart.readByte(address);
Cartridge::readByte (this=0x7fffffff3860, address=340) at /home/caidenmarley/gameboy/src/cartridge.cpp:118
118	    if(isMbc2){
135	    if(isMbc1){
159	    if(address < 0x8000){
160	        return romData.at(address);
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=340) at /usr/include/c++/11/bits/stl_vector.h:1094
1094		_M_range_check(__n);
std::vector<unsigned char, std::allocator<unsigned char> >::_M_range_check (this=0x7fffffff38d0, __n=340) at /usr/include/c++/11/bits/stl_vector.h:1072
1072		if (__n >= this->size())
std::vector<unsigned char, std::allocator<unsigned char> >::size (this=0x7fffffff38d0) at /usr/include/c++/11/bits/stl_vector.h:919
919	      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
std::vector<unsigned char, std::allocator<unsigned char> >::_M_range_check (this=0x7fffffff38d0, __n=340) at /usr/include/c++/11/bits/stl_vector.h:1072
1072		if (__n >= this->size())
1077	      }
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=340) at /usr/include/c++/11/bits/stl_vector.h:1095
1095		return (*this)[__n];
std::vector<unsigned char, std::allocator<unsigned char> >::operator[] (this=0x7fffffff38d0, __n=340) at /usr/include/c++/11/bits/stl_vector.h:1046
1046		return *(this->_M_impl._M_start + __n);
1047	      }
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=340) at /usr/include/c++/11/bits/stl_vector.h:1096
1096	      }
Cartridge::readByte (this=0x7fffffff3860, address=340) at /home/caidenmarley/gameboy/src/cartridge.cpp:160
160	        return romData.at(address);
168	}
Bus::read (this=0x7fffffff3910, address=340) at /home/caidenmarley/gameboy/src/bus.cpp:24
24	        return cart.readByte(address);
82	}
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:58
58	    return decodeAndExecute(*this, bus, opcode);
decodeAndExecute (cpu=..., bus=..., opcode=175 '\257') at /home/caidenmarley/gameboy/include/instructions.h:93
93	    switch(opcode){
1337	                xorWithA(cpu.A, cpu);
xorWithA (value=1 '\001', cpu=...) at /home/caidenmarley/gameboy/include/instructions.h:56
56	    cpu.A ^= value;
57	    cpu.setFlag(cpu.zF, cpu.A==0);
CPU::setFlag (this=0x7fffffff37c0, isolatingBit=128 '\200', on=true) at /home/caidenmarley/gameboy/include/cpu.h:64
64	        if(on){
65	            F |= isolatingBit;
69	    }
xorWithA (value=1 '\001', cpu=...) at /home/caidenmarley/gameboy/include/instructions.h:58
58	    cpu.setFlag(cpu.nF, false);
CPU::setFlag (this=0x7fffffff37c0, isolatingBit=64 '@', on=false) at /home/caidenmarley/gameboy/include/cpu.h:64
64	        if(on){
67	            F &= ~isolatingBit;
69	    }
xorWithA (value=1 '\001', cpu=...) at /home/caidenmarley/gameboy/include/instructions.h:59
59	    cpu.setFlag(cpu.hF, false);
CPU::setFlag (this=0x7fffffff37c0, isolatingBit=32 ' ', on=false) at /home/caidenmarley/gameboy/include/cpu.h:64
64	        if(on){
67	            F &= ~isolatingBit;
69	    }
xorWithA (value=1 '\001', cpu=...) at /home/caidenmarley/gameboy/include/instructions.h:60
60	    cpu.setFlag(cpu.cF, false);
CPU::setFlag (this=0x7fffffff37c0, isolatingBit=16 '\020', on=false) at /home/caidenmarley/gameboy/include/cpu.h:64
64	        if(on){
67	            F &= ~isolatingBit;
69	    }
xorWithA (value=1 '\001', cpu=...) at /home/caidenmarley/gameboy/include/instructions.h:61
61	}
decodeAndExecute (cpu=..., bus=..., opcode=175 '\257') at /home/caidenmarley/gameboy/include/instructions.h:1338
1338	                return 1;
1886	}
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:58
58	    return decodeAndExecute(*this, bus, opcode);
59	}
main (argc=2, argv=0x7fffffffd6e8) at /home/caidenmarley/gameboy/main.cpp:124
124	            bus.step(m * 4, cpu);
Bus::step (this=0x7fffffff3910, tStates=4, cpu=...) at /home/caidenmarley/gameboy/src/bus.cpp:140
140	    timer.step(tStates, cpu);
Timer::step (this=0x7fffffffb4a0, tStates=4, cpu=...) at /home/caidenmarley/gameboy/src/timer.cpp:8
8	    divCounter += tStates;
9	    while(divCounter >= 256){
15	    if(TAC & 0x04){
30	}
Bus::step (this=0x7fffffff3910, tStates=4, cpu=...) at /home/caidenmarley/gameboy/src/bus.cpp:141
141	    ppu.step(tStates, cpu);
PPU::step (this=0x7fffffff3910, tStates=4, cpu=...) at /home/caidenmarley/gameboy/src/ppu.cpp:17
17	void PPU::step(int tStates, CPU& cpu){
18	    stepDma(tStates);
PPU::stepDma (this=0x7fffffff3910, cycles=4) at /home/caidenmarley/gameboy/include/ppu.h:151
151	        if(!oamDmaActive) return;
156	    }
PPU::step (this=0x7fffffff3910, tStates=4, cpu=...) at /home/caidenmarley/gameboy/src/ppu.cpp:20
20	    if(!(LCDC & 0x80)){
24	    dotCounter += tStates;
27	        uint8_t mode = STAT & 0x03;
28	        int needed = 0;
30	        switch(mode){
46	            case 1: needed = 4560; break;
50	        if (dotCounter < needed){
51	            break;
142	}
Bus::step (this=0x7fffffff3910, tStates=4, cpu=...) at /home/caidenmarley/gameboy/src/bus.cpp:143
143	}
main (argc=2, argv=0x7fffffffd6e8) at /home/caidenmarley/gameboy/main.cpp:122
122	        while (!bus.ppu.isFrameReady()) {
PPU::isFrameReady (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:46
46	        return frameReady;
47	    }
main (argc=2, argv=0x7fffffffd6e8) at /home/caidenmarley/gameboy/main.cpp:122
122	        while (!bus.ppu.isFrameReady()) {
123	            int m = cpu.step();
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:10
10	    if(imeEnabledNextStep){
16	    if(stopped){
26	    if(halted){
35	    uint8_t ieaValue = bus.read(INTERRUPT_ENABLE_ADDRESS);
Bus::read (this=0x7fffffff3910, address=65535) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::read (this=0x7fffffff3910, address=65535) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
22	    if(address < 0x8000){
25	    }else if(address < 0xA000){
28	    }else if(address < 0xC000){
31	    }else if(address < 0xE000){
34	    }else if(address < 0xFE00){
37	    }else if(address < 0xFEA0){
40	    }else if(address < 0xFF00){
43	    }else if(address == 0xFF00){
63	    }else if(address < 0xFF04){
66	    }else if(address < 0xFF08){
69	    }else if(address >= 0xFF40 && address <= 0xFF4B){
72	    }else if(address < 0xFF80){
75	    }else if(address < 0xFFFF){
80	        return ieReg;
82	}
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:36
36	    uint8_t ifaValue = bus.read(INTERRUPT_FLAG_ADDRESS);
Bus::read (this=0x7fffffff3910, address=65295) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::read (this=0x7fffffff3910, address=65295) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
22	    if(address < 0x8000){
25	    }else if(address < 0xA000){
28	    }else if(address < 0xC000){
31	    }else if(address < 0xE000){
34	    }else if(address < 0xFE00){
37	    }else if(address < 0xFEA0){
40	    }else if(address < 0xFF00){
43	    }else if(address == 0xFF00){
63	    }else if(address < 0xFF04){
66	    }else if(address < 0xFF08){
69	    }else if(address >= 0xFF40 && address <= 0xFF4B){
72	    }else if(address < 0xFF80){
74	        return ioRegs[address - 0xFF00];
82	}
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:37
37	    uint8_t interruptRequest = ieaValue & ifaValue;
38	    if(IME && interruptRequest){
57	    uint8_t opcode = bus.read(PC++);
Bus::read (this=0x7fffffff3910, address=341) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::read (this=0x7fffffff3910, address=341) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
22	    if(address < 0x8000){
24	        return cart.readByte(address);
Cartridge::readByte (this=0x7fffffff3860, address=341) at /home/caidenmarley/gameboy/src/cartridge.cpp:118
118	    if(isMbc2){
135	    if(isMbc1){
159	    if(address < 0x8000){
160	        return romData.at(address);
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=341) at /usr/include/c++/11/bits/stl_vector.h:1094
1094		_M_range_check(__n);
std::vector<unsigned char, std::allocator<unsigned char> >::_M_range_check (this=0x7fffffff38d0, __n=341) at /usr/include/c++/11/bits/stl_vector.h:1072
1072		if (__n >= this->size())
std::vector<unsigned char, std::allocator<unsigned char> >::size (this=0x7fffffff38d0) at /usr/include/c++/11/bits/stl_vector.h:919
919	      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
std::vector<unsigned char, std::allocator<unsigned char> >::_M_range_check (this=0x7fffffff38d0, __n=341) at /usr/include/c++/11/bits/stl_vector.h:1072
1072		if (__n >= this->size())
1077	      }
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=341) at /usr/include/c++/11/bits/stl_vector.h:1095
1095		return (*this)[__n];
std::vector<unsigned char, std::allocator<unsigned char> >::operator[] (this=0x7fffffff38d0, __n=341) at /usr/include/c++/11/bits/stl_vector.h:1046
1046		return *(this->_M_impl._M_start + __n);
1047	      }
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=341) at /usr/include/c++/11/bits/stl_vector.h:1096
1096	      }
Cartridge::readByte (this=0x7fffffff3860, address=341) at /home/caidenmarley/gameboy/src/cartridge.cpp:160
160	        return romData.at(address);
168	}
Bus::read (this=0x7fffffff3910, address=341) at /home/caidenmarley/gameboy/src/bus.cpp:24
24	        return cart.readByte(address);
82	}
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:58
58	    return decodeAndExecute(*this, bus, opcode);
decodeAndExecute (cpu=..., bus=..., opcode=24 '\030') at /home/caidenmarley/gameboy/include/instructions.h:93
93	    switch(opcode){
295	                int8_t offset = int8_t(bus.read(cpu.PC++));
Bus::read (this=0x7fffffff3910, address=342) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::read (this=0x7fffffff3910, address=342) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
22	    if(address < 0x8000){
24	        return cart.readByte(address);
Cartridge::readByte (this=0x7fffffff3860, address=342) at /home/caidenmarley/gameboy/src/cartridge.cpp:118
118	    if(isMbc2){
135	    if(isMbc1){
159	    if(address < 0x8000){
160	        return romData.at(address);
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=342) at /usr/include/c++/11/bits/stl_vector.h:1094
1094		_M_range_check(__n);
std::vector<unsigned char, std::allocator<unsigned char> >::_M_range_check (this=0x7fffffff38d0, __n=342) at /usr/include/c++/11/bits/stl_vector.h:1072
1072		if (__n >= this->size())
std::vector<unsigned char, std::allocator<unsigned char> >::size (this=0x7fffffff38d0) at /usr/include/c++/11/bits/stl_vector.h:919
919	      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
std::vector<unsigned char, std::allocator<unsigned char> >::_M_range_check (this=0x7fffffff38d0, __n=342) at /usr/include/c++/11/bits/stl_vector.h:1072
1072		if (__n >= this->size())
1077	      }
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=342) at /usr/include/c++/11/bits/stl_vector.h:1095
1095		return (*this)[__n];
std::vector<unsigned char, std::allocator<unsigned char> >::operator[] (this=0x7fffffff38d0, __n=342) at /usr/include/c++/11/bits/stl_vector.h:1046
1046		return *(this->_M_impl._M_start + __n);
1047	      }
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=342) at /usr/include/c++/11/bits/stl_vector.h:1096
1096	      }
Cartridge::readByte (this=0x7fffffff3860, address=342) at /home/caidenmarley/gameboy/src/cartridge.cpp:160
160	        return romData.at(address);
168	}
Bus::read (this=0x7fffffff3910, address=342) at /home/caidenmarley/gameboy/src/bus.cpp:24
24	        return cart.readByte(address);
82	}
decodeAndExecute (cpu=..., bus=..., opcode=24 '\030') at /home/caidenmarley/gameboy/include/instructions.h:295
295	                int8_t offset = int8_t(bus.read(cpu.PC++));
296	                cpu.PC += offset;
297	                return 3;
1886	}
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:58
58	    return decodeAndExecute(*this, bus, opcode);
59	}
main (argc=2, argv=0x7fffffffd6e8) at /home/caidenmarley/gameboy/main.cpp:124
124	            bus.step(m * 4, cpu);
Bus::step (this=0x7fffffff3910, tStates=12, cpu=...) at /home/caidenmarley/gameboy/src/bus.cpp:140
140	    timer.step(tStates, cpu);
Timer::step (this=0x7fffffffb4a0, tStates=12, cpu=...) at /home/caidenmarley/gameboy/src/timer.cpp:8
8	    divCounter += tStates;
9	    while(divCounter >= 256){
15	    if(TAC & 0x04){
30	}
Bus::step (this=0x7fffffff3910, tStates=12, cpu=...) at /home/caidenmarley/gameboy/src/bus.cpp:141
141	    ppu.step(tStates, cpu);
PPU::step (this=0x7fffffff3910, tStates=12, cpu=...) at /home/caidenmarley/gameboy/src/ppu.cpp:17
17	void PPU::step(int tStates, CPU& cpu){
18	    stepDma(tStates);
PPU::stepDma (this=0x7fffffff3910, cycles=12) at /home/caidenmarley/gameboy/include/ppu.h:151
151	        if(!oamDmaActive) return;
156	    }
PPU::step (this=0x7fffffff3910, tStates=12, cpu=...) at /home/caidenmarley/gameboy/src/ppu.cpp:20
20	    if(!(LCDC & 0x80)){
24	    dotCounter += tStates;
27	        uint8_t mode = STAT & 0x03;
28	        int needed = 0;
30	        switch(mode){
46	            case 1: needed = 4560; break;
50	        if (dotCounter < needed){
51	            break;
142	}
Bus::step (this=0x7fffffff3910, tStates=12, cpu=...) at /home/caidenmarley/gameboy/src/bus.cpp:143
143	}
main (argc=2, argv=0x7fffffffd6e8) at /home/caidenmarley/gameboy/main.cpp:122
122	        while (!bus.ppu.isFrameReady()) {
PPU::isFrameReady (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:46
46	        return frameReady;
47	    }
main (argc=2, argv=0x7fffffffd6e8) at /home/caidenmarley/gameboy/main.cpp:122
122	        while (!bus.ppu.isFrameReady()) {
123	            int m = cpu.step();
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:10
10	    if(imeEnabledNextStep){
16	    if(stopped){
26	    if(halted){
35	    uint8_t ieaValue = bus.read(INTERRUPT_ENABLE_ADDRESS);
Bus::read (this=0x7fffffff3910, address=65535) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::read (this=0x7fffffff3910, address=65535) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
22	    if(address < 0x8000){
25	    }else if(address < 0xA000){
28	    }else if(address < 0xC000){
31	    }else if(address < 0xE000){
34	    }else if(address < 0xFE00){
37	    }else if(address < 0xFEA0){
40	    }else if(address < 0xFF00){
43	    }else if(address == 0xFF00){
63	    }else if(address < 0xFF04){
66	    }else if(address < 0xFF08){
69	    }else if(address >= 0xFF40 && address <= 0xFF4B){
72	    }else if(address < 0xFF80){
75	    }else if(address < 0xFFFF){
80	        return ieReg;
82	}
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:36
36	    uint8_t ifaValue = bus.read(INTERRUPT_FLAG_ADDRESS);
Bus::read (this=0x7fffffff3910, address=65295) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::read (this=0x7fffffff3910, address=65295) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
22	    if(address < 0x8000){
25	    }else if(address < 0xA000){
28	    }else if(address < 0xC000){
31	    }else if(address < 0xE000){
34	    }else if(address < 0xFE00){
37	    }else if(address < 0xFEA0){
40	    }else if(address < 0xFF00){
43	    }else if(address == 0xFF00){
63	    }else if(address < 0xFF04){
66	    }else if(address < 0xFF08){
69	    }else if(address >= 0xFF40 && address <= 0xFF4B){
72	    }else if(address < 0xFF80){
74	        return ioRegs[address - 0xFF00];
82	}
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:37
37	    uint8_t interruptRequest = ieaValue & ifaValue;
38	    if(IME && interruptRequest){
57	    uint8_t opcode = bus.read(PC++);
Bus::read (this=0x7fffffff3910, address=345) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::read (this=0x7fffffff3910, address=345) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
22	    if(address < 0x8000){
24	        return cart.readByte(address);
Cartridge::readByte (this=0x7fffffff3860, address=345) at /home/caidenmarley/gameboy/src/cartridge.cpp:118
118	    if(isMbc2){
135	    if(isMbc1){
159	    if(address < 0x8000){
160	        return romData.at(address);
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=345) at /usr/include/c++/11/bits/stl_vector.h:1094
1094		_M_range_check(__n);
std::vector<unsigned char, std::allocator<unsigned char> >::_M_range_check (this=0x7fffffff38d0, __n=345) at /usr/include/c++/11/bits/stl_vector.h:1072
1072		if (__n >= this->size())
std::vector<unsigned char, std::allocator<unsigned char> >::size (this=0x7fffffff38d0) at /usr/include/c++/11/bits/stl_vector.h:919
919	      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
std::vector<unsigned char, std::allocator<unsigned char> >::_M_range_check (this=0x7fffffff38d0, __n=345) at /usr/include/c++/11/bits/stl_vector.h:1072
1072		if (__n >= this->size())
1077	      }
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=345) at /usr/include/c++/11/bits/stl_vector.h:1095
1095		return (*this)[__n];
std::vector<unsigned char, std::allocator<unsigned char> >::operator[] (this=0x7fffffff38d0, __n=345) at /usr/include/c++/11/bits/stl_vector.h:1046
1046		return *(this->_M_impl._M_start + __n);
1047	      }
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=345) at /usr/include/c++/11/bits/stl_vector.h:1096
1096	      }
Cartridge::readByte (this=0x7fffffff3860, address=345) at /home/caidenmarley/gameboy/src/cartridge.cpp:160
160	        return romData.at(address);
168	}
Bus::read (this=0x7fffffff3910, address=345) at /home/caidenmarley/gameboy/src/bus.cpp:24
24	        return cart.readByte(address);
82	}
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:58
58	    return decodeAndExecute(*this, bus, opcode);
decodeAndExecute (cpu=..., bus=..., opcode=234 '\352') at /home/caidenmarley/gameboy/include/instructions.h:93
93	    switch(opcode){
1774	                uint8_t low = bus.read(cpu.PC++);
Bus::read (this=0x7fffffff3910, address=346) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::read (this=0x7fffffff3910, address=346) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
22	    if(address < 0x8000){
24	        return cart.readByte(address);
Cartridge::readByte (this=0x7fffffff3860, address=346) at /home/caidenmarley/gameboy/src/cartridge.cpp:118
118	    if(isMbc2){
135	    if(isMbc1){
159	    if(address < 0x8000){
160	        return romData.at(address);
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=346) at /usr/include/c++/11/bits/stl_vector.h:1094
1094		_M_range_check(__n);
std::vector<unsigned char, std::allocator<unsigned char> >::_M_range_check (this=0x7fffffff38d0, __n=346) at /usr/include/c++/11/bits/stl_vector.h:1072
1072		if (__n >= this->size())
std::vector<unsigned char, std::allocator<unsigned char> >::size (this=0x7fffffff38d0) at /usr/include/c++/11/bits/stl_vector.h:919
919	      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
std::vector<unsigned char, std::allocator<unsigned char> >::_M_range_check (this=0x7fffffff38d0, __n=346) at /usr/include/c++/11/bits/stl_vector.h:1072
1072		if (__n >= this->size())
1077	      }
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=346) at /usr/include/c++/11/bits/stl_vector.h:1095
1095		return (*this)[__n];
std::vector<unsigned char, std::allocator<unsigned char> >::operator[] (this=0x7fffffff38d0, __n=346) at /usr/include/c++/11/bits/stl_vector.h:1046
1046		return *(this->_M_impl._M_start + __n);
1047	      }
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=346) at /usr/include/c++/11/bits/stl_vector.h:1096
1096	      }
Cartridge::readByte (this=0x7fffffff3860, address=346) at /home/caidenmarley/gameboy/src/cartridge.cpp:160
160	        return romData.at(address);
168	}
Bus::read (this=0x7fffffff3910, address=346) at /home/caidenmarley/gameboy/src/bus.cpp:24
24	        return cart.readByte(address);
82	}
decodeAndExecute (cpu=..., bus=..., opcode=234 '\352') at /home/caidenmarley/gameboy/include/instructions.h:1775
1775	                uint8_t high = bus.read(cpu.PC++);
Bus::read (this=0x7fffffff3910, address=347) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::read (this=0x7fffffff3910, address=347) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
22	    if(address < 0x8000){
24	        return cart.readByte(address);
Cartridge::readByte (this=0x7fffffff3860, address=347) at /home/caidenmarley/gameboy/src/cartridge.cpp:118
118	    if(isMbc2){
135	    if(isMbc1){
159	    if(address < 0x8000){
160	        return romData.at(address);
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=347) at /usr/include/c++/11/bits/stl_vector.h:1094
1094		_M_range_check(__n);
std::vector<unsigned char, std::allocator<unsigned char> >::_M_range_check (this=0x7fffffff38d0, __n=347) at /usr/include/c++/11/bits/stl_vector.h:1072
1072		if (__n >= this->size())
std::vector<unsigned char, std::allocator<unsigned char> >::size (this=0x7fffffff38d0) at /usr/include/c++/11/bits/stl_vector.h:919
919	      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
std::vector<unsigned char, std::allocator<unsigned char> >::_M_range_check (this=0x7fffffff38d0, __n=347) at /usr/include/c++/11/bits/stl_vector.h:1072
1072		if (__n >= this->size())
1077	      }
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=347) at /usr/include/c++/11/bits/stl_vector.h:1095
1095		return (*this)[__n];
std::vector<unsigned char, std::allocator<unsigned char> >::operator[] (this=0x7fffffff38d0, __n=347) at /usr/include/c++/11/bits/stl_vector.h:1046
1046		return *(this->_M_impl._M_start + __n);
1047	      }
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=347) at /usr/include/c++/11/bits/stl_vector.h:1096
1096	      }
Cartridge::readByte (this=0x7fffffff3860, address=347) at /home/caidenmarley/gameboy/src/cartridge.cpp:160
160	        return romData.at(address);
168	}
Bus::read (this=0x7fffffff3910, address=347) at /home/caidenmarley/gameboy/src/bus.cpp:24
24	        return cart.readByte(address);
82	}
decodeAndExecute (cpu=..., bus=..., opcode=234 '\352') at /home/caidenmarley/gameboy/include/instructions.h:1776
1776	                uint16_t result = uint16_t(high << 8) | uint16_t(low);
1777	                bus.write(result, cpu.A);
Bus::write (this=0x7fffffff3910, address=53018, byte=0 '\000') at /home/caidenmarley/gameboy/src/bus.cpp:85
85	    if(address == 0xFF00){
89	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::write (this=0x7fffffff3910, address=53018, byte=0 '\000') at /home/caidenmarley/gameboy/src/bus.cpp:89
89	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
94	    if(address < 0x8000){
97	    }else if(address < 0xA000){
100	    }else if(address < 0xC000){
103	    }else if(address < 0xE000){
105	        wram[address - 0xC000] = byte;
137	}
decodeAndExecute (cpu=..., bus=..., opcode=234 '\352') at /home/caidenmarley/gameboy/include/instructions.h:1778
1778	                return 4;
1886	}
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:58
58	    return decodeAndExecute(*this, bus, opcode);
59	}
main (argc=2, argv=0x7fffffffd6e8) at /home/caidenmarley/gameboy/main.cpp:124
124	            bus.step(m * 4, cpu);
Bus::step (this=0x7fffffff3910, tStates=16, cpu=...) at /home/caidenmarley/gameboy/src/bus.cpp:140
140	    timer.step(tStates, cpu);
Timer::step (this=0x7fffffffb4a0, tStates=16, cpu=...) at /home/caidenmarley/gameboy/src/timer.cpp:8
8	    divCounter += tStates;
9	    while(divCounter >= 256){
15	    if(TAC & 0x04){
30	}
Bus::step (this=0x7fffffff3910, tStates=16, cpu=...) at /home/caidenmarley/gameboy/src/bus.cpp:141
141	    ppu.step(tStates, cpu);
PPU::step (this=0x7fffffff3910, tStates=16, cpu=...) at /home/caidenmarley/gameboy/src/ppu.cpp:17
17	void PPU::step(int tStates, CPU& cpu){
18	    stepDma(tStates);
PPU::stepDma (this=0x7fffffff3910, cycles=16) at /home/caidenmarley/gameboy/include/ppu.h:151
151	        if(!oamDmaActive) return;
156	    }
PPU::step (this=0x7fffffff3910, tStates=16, cpu=...) at /home/caidenmarley/gameboy/src/ppu.cpp:20
20	    if(!(LCDC & 0x80)){
24	    dotCounter += tStates;
27	        uint8_t mode = STAT & 0x03;
28	        int needed = 0;
30	        switch(mode){
46	            case 1: needed = 4560; break;
50	        if (dotCounter < needed){
51	            break;
142	}
Bus::step (this=0x7fffffff3910, tStates=16, cpu=...) at /home/caidenmarley/gameboy/src/bus.cpp:143
143	}
main (argc=2, argv=0x7fffffffd6e8) at /home/caidenmarley/gameboy/main.cpp:122
122	        while (!bus.ppu.isFrameReady()) {
PPU::isFrameReady (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:46
46	        return frameReady;
47	    }
main (argc=2, argv=0x7fffffffd6e8) at /home/caidenmarley/gameboy/main.cpp:122
122	        while (!bus.ppu.isFrameReady()) {
123	            int m = cpu.step();
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:10
10	    if(imeEnabledNextStep){
16	    if(stopped){
26	    if(halted){
35	    uint8_t ieaValue = bus.read(INTERRUPT_ENABLE_ADDRESS);
Bus::read (this=0x7fffffff3910, address=65535) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::read (this=0x7fffffff3910, address=65535) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
22	    if(address < 0x8000){
25	    }else if(address < 0xA000){
28	    }else if(address < 0xC000){
31	    }else if(address < 0xE000){
34	    }else if(address < 0xFE00){
37	    }else if(address < 0xFEA0){
40	    }else if(address < 0xFF00){
43	    }else if(address == 0xFF00){
63	    }else if(address < 0xFF04){
66	    }else if(address < 0xFF08){
69	    }else if(address >= 0xFF40 && address <= 0xFF4B){
72	    }else if(address < 0xFF80){
75	    }else if(address < 0xFFFF){
80	        return ieReg;
82	}
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:36
36	    uint8_t ifaValue = bus.read(INTERRUPT_FLAG_ADDRESS);
Bus::read (this=0x7fffffff3910, address=65295) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::read (this=0x7fffffff3910, address=65295) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
22	    if(address < 0x8000){
25	    }else if(address < 0xA000){
28	    }else if(address < 0xC000){
31	    }else if(address < 0xE000){
34	    }else if(address < 0xFE00){
37	    }else if(address < 0xFEA0){
40	    }else if(address < 0xFF00){
43	    }else if(address == 0xFF00){
63	    }else if(address < 0xFF04){
66	    }else if(address < 0xFF08){
69	    }else if(address >= 0xFF40 && address <= 0xFF4B){
72	    }else if(address < 0xFF80){
74	        return ioRegs[address - 0xFF00];
82	}
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:37
37	    uint8_t interruptRequest = ieaValue & ifaValue;
38	    if(IME && interruptRequest){
57	    uint8_t opcode = bus.read(PC++);
Bus::read (this=0x7fffffff3910, address=348) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::read (this=0x7fffffff3910, address=348) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
22	    if(address < 0x8000){
24	        return cart.readByte(address);
Cartridge::readByte (this=0x7fffffff3860, address=348) at /home/caidenmarley/gameboy/src/cartridge.cpp:118
118	    if(isMbc2){
135	    if(isMbc1){
159	    if(address < 0x8000){
160	        return romData.at(address);
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=348) at /usr/include/c++/11/bits/stl_vector.h:1094
1094		_M_range_check(__n);
std::vector<unsigned char, std::allocator<unsigned char> >::_M_range_check (this=0x7fffffff38d0, __n=348) at /usr/include/c++/11/bits/stl_vector.h:1072
1072		if (__n >= this->size())
std::vector<unsigned char, std::allocator<unsigned char> >::size (this=0x7fffffff38d0) at /usr/include/c++/11/bits/stl_vector.h:919
919	      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
std::vector<unsigned char, std::allocator<unsigned char> >::_M_range_check (this=0x7fffffff38d0, __n=348) at /usr/include/c++/11/bits/stl_vector.h:1072
1072		if (__n >= this->size())
1077	      }
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=348) at /usr/include/c++/11/bits/stl_vector.h:1095
1095		return (*this)[__n];
std::vector<unsigned char, std::allocator<unsigned char> >::operator[] (this=0x7fffffff38d0, __n=348) at /usr/include/c++/11/bits/stl_vector.h:1046
1046		return *(this->_M_impl._M_start + __n);
1047	      }
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=348) at /usr/include/c++/11/bits/stl_vector.h:1096
1096	      }
Cartridge::readByte (this=0x7fffffff3860, address=348) at /home/caidenmarley/gameboy/src/cartridge.cpp:160
160	        return romData.at(address);
168	}
Bus::read (this=0x7fffffff3910, address=348) at /home/caidenmarley/gameboy/src/bus.cpp:24
24	        return cart.readByte(address);
82	}
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:58
58	    return decodeAndExecute(*this, bus, opcode);
decodeAndExecute (cpu=..., bus=..., opcode=195 '\303') at /home/caidenmarley/gameboy/include/instructions.h:93
93	    switch(opcode){
1468	                uint8_t low = bus.read(cpu.PC++);
Bus::read (this=0x7fffffff3910, address=349) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::read (this=0x7fffffff3910, address=349) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
22	    if(address < 0x8000){
24	        return cart.readByte(address);
Cartridge::readByte (this=0x7fffffff3860, address=349) at /home/caidenmarley/gameboy/src/cartridge.cpp:118
118	    if(isMbc2){
135	    if(isMbc1){
159	    if(address < 0x8000){
160	        return romData.at(address);
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=349) at /usr/include/c++/11/bits/stl_vector.h:1094
1094		_M_range_check(__n);
std::vector<unsigned char, std::allocator<unsigned char> >::_M_range_check (this=0x7fffffff38d0, __n=349) at /usr/include/c++/11/bits/stl_vector.h:1072
1072		if (__n >= this->size())
std::vector<unsigned char, std::allocator<unsigned char> >::size (this=0x7fffffff38d0) at /usr/include/c++/11/bits/stl_vector.h:919
919	      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
std::vector<unsigned char, std::allocator<unsigned char> >::_M_range_check (this=0x7fffffff38d0, __n=349) at /usr/include/c++/11/bits/stl_vector.h:1072
1072		if (__n >= this->size())
1077	      }
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=349) at /usr/include/c++/11/bits/stl_vector.h:1095
1095		return (*this)[__n];
std::vector<unsigned char, std::allocator<unsigned char> >::operator[] (this=0x7fffffff38d0, __n=349) at /usr/include/c++/11/bits/stl_vector.h:1046
1046		return *(this->_M_impl._M_start + __n);
1047	      }
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=349) at /usr/include/c++/11/bits/stl_vector.h:1096
1096	      }
Cartridge::readByte (this=0x7fffffff3860, address=349) at /home/caidenmarley/gameboy/src/cartridge.cpp:160
160	        return romData.at(address);
168	}
Bus::read (this=0x7fffffff3910, address=349) at /home/caidenmarley/gameboy/src/bus.cpp:24
24	        return cart.readByte(address);
82	}
decodeAndExecute (cpu=..., bus=..., opcode=195 '\303') at /home/caidenmarley/gameboy/include/instructions.h:1469
1469	                uint8_t high = bus.read(cpu.PC++);
Bus::read (this=0x7fffffff3910, address=350) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::read (this=0x7fffffff3910, address=350) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
22	    if(address < 0x8000){
24	        return cart.readByte(address);
Cartridge::readByte (this=0x7fffffff3860, address=350) at /home/caidenmarley/gameboy/src/cartridge.cpp:118
118	    if(isMbc2){
135	    if(isMbc1){
159	    if(address < 0x8000){
160	        return romData.at(address);
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=350) at /usr/include/c++/11/bits/stl_vector.h:1094
1094		_M_range_check(__n);
std::vector<unsigned char, std::allocator<unsigned char> >::_M_range_check (this=0x7fffffff38d0, __n=350) at /usr/include/c++/11/bits/stl_vector.h:1072
1072		if (__n >= this->size())
std::vector<unsigned char, std::allocator<unsigned char> >::size (this=0x7fffffff38d0) at /usr/include/c++/11/bits/stl_vector.h:919
919	      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
std::vector<unsigned char, std::allocator<unsigned char> >::_M_range_check (this=0x7fffffff38d0, __n=350) at /usr/include/c++/11/bits/stl_vector.h:1072
1072		if (__n >= this->size())
1077	      }
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=350) at /usr/include/c++/11/bits/stl_vector.h:1095
1095		return (*this)[__n];
std::vector<unsigned char, std::allocator<unsigned char> >::operator[] (this=0x7fffffff38d0, __n=350) at /usr/include/c++/11/bits/stl_vector.h:1046
1046		return *(this->_M_impl._M_start + __n);
1047	      }
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=350) at /usr/include/c++/11/bits/stl_vector.h:1096
1096	      }
Cartridge::readByte (this=0x7fffffff3860, address=350) at /home/caidenmarley/gameboy/src/cartridge.cpp:160
160	        return romData.at(address);
168	}
Bus::read (this=0x7fffffff3910, address=350) at /home/caidenmarley/gameboy/src/bus.cpp:24
24	        return cart.readByte(address);
82	}
decodeAndExecute (cpu=..., bus=..., opcode=195 '\303') at /home/caidenmarley/gameboy/include/instructions.h:1470
1470	                uint16_t result = uint16_t(high << 8) | uint16_t(low);
1471	                cpu.PC = result;
1472	                return 4;
1886	}
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:58
58	    return decodeAndExecute(*this, bus, opcode);
59	}
main (argc=2, argv=0x7fffffffd6e8) at /home/caidenmarley/gameboy/main.cpp:124
124	            bus.step(m * 4, cpu);
Bus::step (this=0x7fffffff3910, tStates=16, cpu=...) at /home/caidenmarley/gameboy/src/bus.cpp:140
140	    timer.step(tStates, cpu);
Timer::step (this=0x7fffffffb4a0, tStates=16, cpu=...) at /home/caidenmarley/gameboy/src/timer.cpp:8
8	    divCounter += tStates;
9	    while(divCounter >= 256){
15	    if(TAC & 0x04){
30	}
Bus::step (this=0x7fffffff3910, tStates=16, cpu=...) at /home/caidenmarley/gameboy/src/bus.cpp:141
141	    ppu.step(tStates, cpu);
PPU::step (this=0x7fffffff3910, tStates=16, cpu=...) at /home/caidenmarley/gameboy/src/ppu.cpp:17
17	void PPU::step(int tStates, CPU& cpu){
18	    stepDma(tStates);
PPU::stepDma (this=0x7fffffff3910, cycles=16) at /home/caidenmarley/gameboy/include/ppu.h:151
151	        if(!oamDmaActive) return;
156	    }
PPU::step (this=0x7fffffff3910, tStates=16, cpu=...) at /home/caidenmarley/gameboy/src/ppu.cpp:20
20	    if(!(LCDC & 0x80)){
24	    dotCounter += tStates;
27	        uint8_t mode = STAT & 0x03;
28	        int needed = 0;
30	        switch(mode){
46	            case 1: needed = 4560; break;
50	        if (dotCounter < needed){
51	            break;
142	}
Bus::step (this=0x7fffffff3910, tStates=16, cpu=...) at /home/caidenmarley/gameboy/src/bus.cpp:143
143	}
main (argc=2, argv=0x7fffffffd6e8) at /home/caidenmarley/gameboy/main.cpp:122
122	        while (!bus.ppu.isFrameReady()) {
PPU::isFrameReady (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:46
46	        return frameReady;
47	    }
main (argc=2, argv=0x7fffffffd6e8) at /home/caidenmarley/gameboy/main.cpp:122
122	        while (!bus.ppu.isFrameReady()) {
123	            int m = cpu.step();
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:10
10	    if(imeEnabledNextStep){
16	    if(stopped){
26	    if(halted){
35	    uint8_t ieaValue = bus.read(INTERRUPT_ENABLE_ADDRESS);
Bus::read (this=0x7fffffff3910, address=65535) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::read (this=0x7fffffff3910, address=65535) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
22	    if(address < 0x8000){
25	    }else if(address < 0xA000){
28	    }else if(address < 0xC000){
31	    }else if(address < 0xE000){
34	    }else if(address < 0xFE00){
37	    }else if(address < 0xFEA0){
40	    }else if(address < 0xFF00){
43	    }else if(address == 0xFF00){
63	    }else if(address < 0xFF04){
66	    }else if(address < 0xFF08){
69	    }else if(address >= 0xFF40 && address <= 0xFF4B){
72	    }else if(address < 0xFF80){
75	    }else if(address < 0xFFFF){
80	        return ieReg;
82	}
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:36
36	    uint8_t ifaValue = bus.read(INTERRUPT_FLAG_ADDRESS);
Bus::read (this=0x7fffffff3910, address=65295) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::read (this=0x7fffffff3910, address=65295) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
22	    if(address < 0x8000){
25	    }else if(address < 0xA000){
28	    }else if(address < 0xC000){
31	    }else if(address < 0xE000){
34	    }else if(address < 0xFE00){
37	    }else if(address < 0xFEA0){
40	    }else if(address < 0xFF00){
43	    }else if(address == 0xFF00){
63	    }else if(address < 0xFF04){
66	    }else if(address < 0xFF08){
69	    }else if(address >= 0xFF40 && address <= 0xFF4B){
72	    }else if(address < 0xFF80){
74	        return ioRegs[address - 0xFF00];
82	}
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:37
37	    uint8_t interruptRequest = ieaValue & ifaValue;
38	    if(IME && interruptRequest){
57	    uint8_t opcode = bus.read(PC++);
Bus::read (this=0x7fffffff3910, address=8020) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::read (this=0x7fffffff3910, address=8020) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
22	    if(address < 0x8000){
24	        return cart.readByte(address);
Cartridge::readByte (this=0x7fffffff3860, address=8020) at /home/caidenmarley/gameboy/src/cartridge.cpp:118
118	    if(isMbc2){
135	    if(isMbc1){
159	    if(address < 0x8000){
160	        return romData.at(address);
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=8020) at /usr/include/c++/11/bits/stl_vector.h:1094
1094		_M_range_check(__n);
std::vector<unsigned char, std::allocator<unsigned char> >::_M_range_check (this=0x7fffffff38d0, __n=8020) at /usr/include/c++/11/bits/stl_vector.h:1072
1072		if (__n >= this->size())
std::vector<unsigned char, std::allocator<unsigned char> >::size (this=0x7fffffff38d0) at /usr/include/c++/11/bits/stl_vector.h:919
919	      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
std::vector<unsigned char, std::allocator<unsigned char> >::_M_range_check (this=0x7fffffff38d0, __n=8020) at /usr/include/c++/11/bits/stl_vector.h:1072
1072		if (__n >= this->size())
1077	      }
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=8020) at /usr/include/c++/11/bits/stl_vector.h:1095
1095		return (*this)[__n];
std::vector<unsigned char, std::allocator<unsigned char> >::operator[] (this=0x7fffffff38d0, __n=8020) at /usr/include/c++/11/bits/stl_vector.h:1046
1046		return *(this->_M_impl._M_start + __n);
1047	      }
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=8020) at /usr/include/c++/11/bits/stl_vector.h:1096
1096	      }
Cartridge::readByte (this=0x7fffffff3860, address=8020) at /home/caidenmarley/gameboy/src/cartridge.cpp:160
160	        return romData.at(address);
168	}
Bus::read (this=0x7fffffff3910, address=8020) at /home/caidenmarley/gameboy/src/bus.cpp:24
24	        return cart.readByte(address);
82	}
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:58
58	    return decodeAndExecute(*this, bus, opcode);
decodeAndExecute (cpu=..., bus=..., opcode=243 '\363') at /home/caidenmarley/gameboy/include/instructions.h:93
93	    switch(opcode){
1814	                cpu.IME = false;
1815	                return 1;
1886	}
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:58
58	    return decodeAndExecute(*this, bus, opcode);
59	}
main (argc=2, argv=0x7fffffffd6e8) at /home/caidenmarley/gameboy/main.cpp:124
124	            bus.step(m * 4, cpu);
Bus::step (this=0x7fffffff3910, tStates=4, cpu=...) at /home/caidenmarley/gameboy/src/bus.cpp:140
140	    timer.step(tStates, cpu);
Timer::step (this=0x7fffffffb4a0, tStates=4, cpu=...) at /home/caidenmarley/gameboy/src/timer.cpp:8
8	    divCounter += tStates;
9	    while(divCounter >= 256){
15	    if(TAC & 0x04){
30	}
Bus::step (this=0x7fffffff3910, tStates=4, cpu=...) at /home/caidenmarley/gameboy/src/bus.cpp:141
141	    ppu.step(tStates, cpu);
PPU::step (this=0x7fffffff3910, tStates=4, cpu=...) at /home/caidenmarley/gameboy/src/ppu.cpp:17
17	void PPU::step(int tStates, CPU& cpu){
18	    stepDma(tStates);
PPU::stepDma (this=0x7fffffff3910, cycles=4) at /home/caidenmarley/gameboy/include/ppu.h:151
151	        if(!oamDmaActive) return;
156	    }
PPU::step (this=0x7fffffff3910, tStates=4, cpu=...) at /home/caidenmarley/gameboy/src/ppu.cpp:20
20	    if(!(LCDC & 0x80)){
24	    dotCounter += tStates;
27	        uint8_t mode = STAT & 0x03;
28	        int needed = 0;
30	        switch(mode){
46	            case 1: needed = 4560; break;
50	        if (dotCounter < needed){
51	            break;
142	}
Bus::step (this=0x7fffffff3910, tStates=4, cpu=...) at /home/caidenmarley/gameboy/src/bus.cpp:143
143	}
main (argc=2, argv=0x7fffffffd6e8) at /home/caidenmarley/gameboy/main.cpp:122
122	        while (!bus.ppu.isFrameReady()) {
PPU::isFrameReady (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:46
46	        return frameReady;
47	    }
main (argc=2, argv=0x7fffffffd6e8) at /home/caidenmarley/gameboy/main.cpp:122
122	        while (!bus.ppu.isFrameReady()) {
123	            int m = cpu.step();
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:10
10	    if(imeEnabledNextStep){
16	    if(stopped){
26	    if(halted){
35	    uint8_t ieaValue = bus.read(INTERRUPT_ENABLE_ADDRESS);
Bus::read (this=0x7fffffff3910, address=65535) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::read (this=0x7fffffff3910, address=65535) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
22	    if(address < 0x8000){
No symbol "bus" in current context.
$5 = 0x91
25	    }else if(address < 0xA000){
28	    }else if(address < 0xC000){
31	    }else if(address < 0xE000){
34	    }else if(address < 0xFE00){
37	    }else if(address < 0xFEA0){
40	    }else if(address < 0xFF00){
43	    }else if(address == 0xFF00){
63	    }else if(address < 0xFF04){
66	    }else if(address < 0xFF08){
69	    }else if(address >= 0xFF40 && address <= 0xFF4B){
72	    }else if(address < 0xFF80){
75	    }else if(address < 0xFFFF){
80	        return ieReg;
82	}
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:36
36	    uint8_t ifaValue = bus.read(INTERRUPT_FLAG_ADDRESS);
Bus::read (this=0x7fffffff3910, address=65295) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::read (this=0x7fffffff3910, address=65295) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
22	    if(address < 0x8000){
25	    }else if(address < 0xA000){
28	    }else if(address < 0xC000){
31	    }else if(address < 0xE000){
34	    }else if(address < 0xFE00){
37	    }else if(address < 0xFEA0){
40	    }else if(address < 0xFF00){
43	    }else if(address == 0xFF00){
63	    }else if(address < 0xFF04){
66	    }else if(address < 0xFF08){
69	    }else if(address >= 0xFF40 && address <= 0xFF4B){
72	    }else if(address < 0xFF80){
74	        return ioRegs[address - 0xFF00];
82	}
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:37
37	    uint8_t interruptRequest = ieaValue & ifaValue;
38	    if(IME && interruptRequest){
57	    uint8_t opcode = bus.read(PC++);
Bus::read (this=0x7fffffff3910, address=8021) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::read (this=0x7fffffff3910, address=8021) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
22	    if(address < 0x8000){
24	        return cart.readByte(address);
Cartridge::readByte (this=0x7fffffff3860, address=8021) at /home/caidenmarley/gameboy/src/cartridge.cpp:118
118	    if(isMbc2){
135	    if(isMbc1){
159	    if(address < 0x8000){
160	        return romData.at(address);
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=8021) at /usr/include/c++/11/bits/stl_vector.h:1094
1094		_M_range_check(__n);
std::vector<unsigned char, std::allocator<unsigned char> >::_M_range_check (this=0x7fffffff38d0, __n=8021) at /usr/include/c++/11/bits/stl_vector.h:1072
1072		if (__n >= this->size())
std::vector<unsigned char, std::allocator<unsigned char> >::size (this=0x7fffffff38d0) at /usr/include/c++/11/bits/stl_vector.h:919
919	      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
std::vector<unsigned char, std::allocator<unsigned char> >::_M_range_check (this=0x7fffffff38d0, __n=8021) at /usr/include/c++/11/bits/stl_vector.h:1072
1072		if (__n >= this->size())
1077	      }
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=8021) at /usr/include/c++/11/bits/stl_vector.h:1095
1095		return (*this)[__n];
std::vector<unsigned char, std::allocator<unsigned char> >::operator[] (this=0x7fffffff38d0, __n=8021) at /usr/include/c++/11/bits/stl_vector.h:1046
1046		return *(this->_M_impl._M_start + __n);
1047	      }
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=8021) at /usr/include/c++/11/bits/stl_vector.h:1096
1096	      }
Cartridge::readByte (this=0x7fffffff3860, address=8021) at /home/caidenmarley/gameboy/src/cartridge.cpp:160
160	        return romData.at(address);
168	}
Bus::read (this=0x7fffffff3910, address=8021) at /home/caidenmarley/gameboy/src/bus.cpp:24
24	        return cart.readByte(address);
82	}
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:58
58	    return decodeAndExecute(*this, bus, opcode);
decodeAndExecute (cpu=..., bus=..., opcode=175 '\257') at /home/caidenmarley/gameboy/include/instructions.h:93
93	    switch(opcode){
1337	                xorWithA(cpu.A, cpu);
xorWithA (value=0 '\000', cpu=...) at /home/caidenmarley/gameboy/include/instructions.h:56
56	    cpu.A ^= value;
57	    cpu.setFlag(cpu.zF, cpu.A==0);
CPU::setFlag (this=0x7fffffff37c0, isolatingBit=128 '\200', on=true) at /home/caidenmarley/gameboy/include/cpu.h:64
64	        if(on){
65	            F |= isolatingBit;
69	    }
xorWithA (value=0 '\000', cpu=...) at /home/caidenmarley/gameboy/include/instructions.h:58
58	    cpu.setFlag(cpu.nF, false);
CPU::setFlag (this=0x7fffffff37c0, isolatingBit=64 '@', on=false) at /home/caidenmarley/gameboy/include/cpu.h:64
64	        if(on){
67	            F &= ~isolatingBit;
69	    }
xorWithA (value=0 '\000', cpu=...) at /home/caidenmarley/gameboy/include/instructions.h:59
59	    cpu.setFlag(cpu.hF, false);
CPU::setFlag (this=0x7fffffff37c0, isolatingBit=32 ' ', on=false) at /home/caidenmarley/gameboy/include/cpu.h:64
64	        if(on){
67	            F &= ~isolatingBit;
69	    }
xorWithA (value=0 '\000', cpu=...) at /home/caidenmarley/gameboy/include/instructions.h:60
60	    cpu.setFlag(cpu.cF, false);
CPU::setFlag (this=0x7fffffff37c0, isolatingBit=16 '\020', on=false) at /home/caidenmarley/gameboy/include/cpu.h:64
64	        if(on){
67	            F &= ~isolatingBit;
69	    }
xorWithA (value=0 '\000', cpu=...) at /home/caidenmarley/gameboy/include/instructions.h:61
61	}
decodeAndExecute (cpu=..., bus=..., opcode=175 '\257') at /home/caidenmarley/gameboy/include/instructions.h:1338
1338	                return 1;
1886	}
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:58
58	    return decodeAndExecute(*this, bus, opcode);
59	}
main (argc=2, argv=0x7fffffffd6e8) at /home/caidenmarley/gameboy/main.cpp:124
124	            bus.step(m * 4, cpu);
Bus::step (this=0x7fffffff3910, tStates=4, cpu=...) at /home/caidenmarley/gameboy/src/bus.cpp:140
140	    timer.step(tStates, cpu);
Timer::step (this=0x7fffffffb4a0, tStates=4, cpu=...) at /home/caidenmarley/gameboy/src/timer.cpp:8
8	    divCounter += tStates;
9	    while(divCounter >= 256){
15	    if(TAC & 0x04){
30	}
Bus::step (this=0x7fffffff3910, tStates=4, cpu=...) at /home/caidenmarley/gameboy/src/bus.cpp:141
141	    ppu.step(tStates, cpu);
PPU::step (this=0x7fffffff3910, tStates=4, cpu=...) at /home/caidenmarley/gameboy/src/ppu.cpp:17
17	void PPU::step(int tStates, CPU& cpu){
18	    stepDma(tStates);
PPU::stepDma (this=0x7fffffff3910, cycles=4) at /home/caidenmarley/gameboy/include/ppu.h:151
151	        if(!oamDmaActive) return;
156	    }
PPU::step (this=0x7fffffff3910, tStates=4, cpu=...) at /home/caidenmarley/gameboy/src/ppu.cpp:20
20	    if(!(LCDC & 0x80)){
24	    dotCounter += tStates;
27	        uint8_t mode = STAT & 0x03;
28	        int needed = 0;
30	        switch(mode){
46	            case 1: needed = 4560; break;
50	        if (dotCounter < needed){
51	            break;
142	}
Bus::step (this=0x7fffffff3910, tStates=4, cpu=...) at /home/caidenmarley/gameboy/src/bus.cpp:143
143	}
main (argc=2, argv=0x7fffffffd6e8) at /home/caidenmarley/gameboy/main.cpp:122
122	        while (!bus.ppu.isFrameReady()) {
PPU::isFrameReady (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:46
46	        return frameReady;
47	    }
main (argc=2, argv=0x7fffffffd6e8) at /home/caidenmarley/gameboy/main.cpp:122
122	        while (!bus.ppu.isFrameReady()) {
123	            int m = cpu.step();
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:10
10	    if(imeEnabledNextStep){
16	    if(stopped){
26	    if(halted){
35	    uint8_t ieaValue = bus.read(INTERRUPT_ENABLE_ADDRESS);
Bus::read (this=0x7fffffff3910, address=65535) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::read (this=0x7fffffff3910, address=65535) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
22	    if(address < 0x8000){
25	    }else if(address < 0xA000){
28	    }else if(address < 0xC000){
31	    }else if(address < 0xE000){
34	    }else if(address < 0xFE00){
37	    }else if(address < 0xFEA0){
40	    }else if(address < 0xFF00){
43	    }else if(address == 0xFF00){
63	    }else if(address < 0xFF04){
66	    }else if(address < 0xFF08){
69	    }else if(address >= 0xFF40 && address <= 0xFF4B){
72	    }else if(address < 0xFF80){
75	    }else if(address < 0xFFFF){
80	        return ieReg;
82	}
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:36
36	    uint8_t ifaValue = bus.read(INTERRUPT_FLAG_ADDRESS);
Bus::read (this=0x7fffffff3910, address=65295) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::read (this=0x7fffffff3910, address=65295) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
22	    if(address < 0x8000){
25	    }else if(address < 0xA000){
28	    }else if(address < 0xC000){
31	    }else if(address < 0xE000){
34	    }else if(address < 0xFE00){
37	    }else if(address < 0xFEA0){
40	    }else if(address < 0xFF00){
43	    }else if(address == 0xFF00){
63	    }else if(address < 0xFF04){
66	    }else if(address < 0xFF08){
69	    }else if(address >= 0xFF40 && address <= 0xFF4B){
72	    }else if(address < 0xFF80){
74	        return ioRegs[address - 0xFF00];
82	}
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:37
37	    uint8_t interruptRequest = ieaValue & ifaValue;
38	    if(IME && interruptRequest){
57	    uint8_t opcode = bus.read(PC++);
Bus::read (this=0x7fffffff3910, address=8022) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::read (this=0x7fffffff3910, address=8022) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
22	    if(address < 0x8000){
24	        return cart.readByte(address);
Cartridge::readByte (this=0x7fffffff3860, address=8022) at /home/caidenmarley/gameboy/src/cartridge.cpp:118
118	    if(isMbc2){
135	    if(isMbc1){
159	    if(address < 0x8000){
160	        return romData.at(address);
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=8022) at /usr/include/c++/11/bits/stl_vector.h:1094
1094		_M_range_check(__n);
std::vector<unsigned char, std::allocator<unsigned char> >::_M_range_check (this=0x7fffffff38d0, __n=8022) at /usr/include/c++/11/bits/stl_vector.h:1072
1072		if (__n >= this->size())
std::vector<unsigned char, std::allocator<unsigned char> >::size (this=0x7fffffff38d0) at /usr/include/c++/11/bits/stl_vector.h:919
919	      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
std::vector<unsigned char, std::allocator<unsigned char> >::_M_range_check (this=0x7fffffff38d0, __n=8022) at /usr/include/c++/11/bits/stl_vector.h:1072
1072		if (__n >= this->size())
1077	      }
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=8022) at /usr/include/c++/11/bits/stl_vector.h:1095
1095		return (*this)[__n];
std::vector<unsigned char, std::allocator<unsigned char> >::operator[] (this=0x7fffffff38d0, __n=8022) at /usr/include/c++/11/bits/stl_vector.h:1046
1046		return *(this->_M_impl._M_start + __n);
1047	      }
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=8022) at /usr/include/c++/11/bits/stl_vector.h:1096
1096	      }
Cartridge::readByte (this=0x7fffffff3860, address=8022) at /home/caidenmarley/gameboy/src/cartridge.cpp:160
160	        return romData.at(address);
168	}
Bus::read (this=0x7fffffff3910, address=8022) at /home/caidenmarley/gameboy/src/bus.cpp:24
24	        return cart.readByte(address);
82	}
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:58
58	    return decodeAndExecute(*this, bus, opcode);
decodeAndExecute (cpu=..., bus=..., opcode=224 '\340') at /home/caidenmarley/gameboy/include/instructions.h:93
93	    switch(opcode){
1701	                uint8_t offset = bus.read(cpu.PC++);
Bus::read (this=0x7fffffff3910, address=8023) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::read (this=0x7fffffff3910, address=8023) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
22	    if(address < 0x8000){
24	        return cart.readByte(address);
Cartridge::readByte (this=0x7fffffff3860, address=8023) at /home/caidenmarley/gameboy/src/cartridge.cpp:118
118	    if(isMbc2){
135	    if(isMbc1){
159	    if(address < 0x8000){
160	        return romData.at(address);
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=8023) at /usr/include/c++/11/bits/stl_vector.h:1094
1094		_M_range_check(__n);
std::vector<unsigned char, std::allocator<unsigned char> >::_M_range_check (this=0x7fffffff38d0, __n=8023) at /usr/include/c++/11/bits/stl_vector.h:1072
1072		if (__n >= this->size())
std::vector<unsigned char, std::allocator<unsigned char> >::size (this=0x7fffffff38d0) at /usr/include/c++/11/bits/stl_vector.h:919
919	      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
std::vector<unsigned char, std::allocator<unsigned char> >::_M_range_check (this=0x7fffffff38d0, __n=8023) at /usr/include/c++/11/bits/stl_vector.h:1072
1072		if (__n >= this->size())
1077	      }
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=8023) at /usr/include/c++/11/bits/stl_vector.h:1095
1095		return (*this)[__n];
std::vector<unsigned char, std::allocator<unsigned char> >::operator[] (this=0x7fffffff38d0, __n=8023) at /usr/include/c++/11/bits/stl_vector.h:1046
1046		return *(this->_M_impl._M_start + __n);
1047	      }
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=8023) at /usr/include/c++/11/bits/stl_vector.h:1096
1096	      }
Cartridge::readByte (this=0x7fffffff3860, address=8023) at /home/caidenmarley/gameboy/src/cartridge.cpp:160
160	        return romData.at(address);
168	}
Bus::read (this=0x7fffffff3910, address=8023) at /home/caidenmarley/gameboy/src/bus.cpp:24
24	        return cart.readByte(address);
82	}
decodeAndExecute (cpu=..., bus=..., opcode=224 '\340') at /home/caidenmarley/gameboy/include/instructions.h:1702
1702	                if ((0xFF00u + offset) == 0xFF40 || (0xFF00u + offset) == 0xFF41) {
1711	                bus.write(0xFF00 + offset, cpu.A);
Bus::write (this=0x7fffffff3910, address=65295, byte=0 '\000') at /home/caidenmarley/gameboy/src/bus.cpp:85
85	    if(address == 0xFF00){
89	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::write (this=0x7fffffff3910, address=65295, byte=0 '\000') at /home/caidenmarley/gameboy/src/bus.cpp:89
89	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
94	    if(address < 0x8000){
97	    }else if(address < 0xA000){
100	    }else if(address < 0xC000){
103	    }else if(address < 0xE000){
106	    }else if(address < 0xFE00){
109	    }else if(address < 0xFEA0){
112	    }else if(address < 0xFF00){
114	    }else if(address < 0xFF04){
117	    }else if(address < 0xFF08){
120	    }else if(address >= 0xFF40 && address <= 0xFF4B){
127	    }else if(address < 0xFF80){
129	        ioRegs[address - 0xFF00] = byte;
137	}
decodeAndExecute (cpu=..., bus=..., opcode=224 '\340') at /home/caidenmarley/gameboy/include/instructions.h:1712
1712	                return 3;
1886	}
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:58
58	    return decodeAndExecute(*this, bus, opcode);
59	}
main (argc=2, argv=0x7fffffffd6e8) at /home/caidenmarley/gameboy/main.cpp:124
124	            bus.step(m * 4, cpu);
Bus::step (this=0x7fffffff3910, tStates=12, cpu=...) at /home/caidenmarley/gameboy/src/bus.cpp:140
140	    timer.step(tStates, cpu);
Timer::step (this=0x7fffffffb4a0, tStates=12, cpu=...) at /home/caidenmarley/gameboy/src/timer.cpp:8
8	    divCounter += tStates;
9	    while(divCounter >= 256){
15	    if(TAC & 0x04){
30	}
Bus::step (this=0x7fffffff3910, tStates=12, cpu=...) at /home/caidenmarley/gameboy/src/bus.cpp:141
141	    ppu.step(tStates, cpu);
PPU::step (this=0x7fffffff3910, tStates=12, cpu=...) at /home/caidenmarley/gameboy/src/ppu.cpp:17
17	void PPU::step(int tStates, CPU& cpu){
18	    stepDma(tStates);
PPU::stepDma (this=0x7fffffff3910, cycles=12) at /home/caidenmarley/gameboy/include/ppu.h:151
151	        if(!oamDmaActive) return;
156	    }
PPU::step (this=0x7fffffff3910, tStates=12, cpu=...) at /home/caidenmarley/gameboy/src/ppu.cpp:20
20	    if(!(LCDC & 0x80)){
24	    dotCounter += tStates;
27	        uint8_t mode = STAT & 0x03;
28	        int needed = 0;
30	        switch(mode){
46	            case 1: needed = 4560; break;
50	        if (dotCounter < needed){
51	            break;
142	}
Bus::step (this=0x7fffffff3910, tStates=12, cpu=...) at /home/caidenmarley/gameboy/src/bus.cpp:143
143	}
main (argc=2, argv=0x7fffffffd6e8) at /home/caidenmarley/gameboy/main.cpp:122
122	        while (!bus.ppu.isFrameReady()) {
PPU::isFrameReady (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:46
46	        return frameReady;
47	    }
main (argc=2, argv=0x7fffffffd6e8) at /home/caidenmarley/gameboy/main.cpp:122
122	        while (!bus.ppu.isFrameReady()) {
123	            int m = cpu.step();
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:10
10	    if(imeEnabledNextStep){
16	    if(stopped){
26	    if(halted){
35	    uint8_t ieaValue = bus.read(INTERRUPT_ENABLE_ADDRESS);
Bus::read (this=0x7fffffff3910, address=65535) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::read (this=0x7fffffff3910, address=65535) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
22	    if(address < 0x8000){
25	    }else if(address < 0xA000){
28	    }else if(address < 0xC000){
31	    }else if(address < 0xE000){
34	    }else if(address < 0xFE00){
37	    }else if(address < 0xFEA0){
40	    }else if(address < 0xFF00){
43	    }else if(address == 0xFF00){
63	    }else if(address < 0xFF04){
66	    }else if(address < 0xFF08){
69	    }else if(address >= 0xFF40 && address <= 0xFF4B){
72	    }else if(address < 0xFF80){
75	    }else if(address < 0xFFFF){
80	        return ieReg;
82	}
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:36
36	    uint8_t ifaValue = bus.read(INTERRUPT_FLAG_ADDRESS);
Bus::read (this=0x7fffffff3910, address=65295) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::read (this=0x7fffffff3910, address=65295) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
22	    if(address < 0x8000){
25	    }else if(address < 0xA000){
28	    }else if(address < 0xC000){
31	    }else if(address < 0xE000){
34	    }else if(address < 0xFE00){
37	    }else if(address < 0xFEA0){
40	    }else if(address < 0xFF00){
43	    }else if(address == 0xFF00){
63	    }else if(address < 0xFF04){
66	    }else if(address < 0xFF08){
69	    }else if(address >= 0xFF40 && address <= 0xFF4B){
72	    }else if(address < 0xFF80){
74	        return ioRegs[address - 0xFF00];
82	}
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:37
37	    uint8_t interruptRequest = ieaValue & ifaValue;
38	    if(IME && interruptRequest){
57	    uint8_t opcode = bus.read(PC++);
Bus::read (this=0x7fffffff3910, address=8024) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::read (this=0x7fffffff3910, address=8024) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
22	    if(address < 0x8000){
24	        return cart.readByte(address);
Cartridge::readByte (this=0x7fffffff3860, address=8024) at /home/caidenmarley/gameboy/src/cartridge.cpp:118
118	    if(isMbc2){
135	    if(isMbc1){
159	    if(address < 0x8000){
160	        return romData.at(address);
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=8024) at /usr/include/c++/11/bits/stl_vector.h:1094
1094		_M_range_check(__n);
std::vector<unsigned char, std::allocator<unsigned char> >::_M_range_check (this=0x7fffffff38d0, __n=8024) at /usr/include/c++/11/bits/stl_vector.h:1072
1072		if (__n >= this->size())
std::vector<unsigned char, std::allocator<unsigned char> >::size (this=0x7fffffff38d0) at /usr/include/c++/11/bits/stl_vector.h:919
919	      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
std::vector<unsigned char, std::allocator<unsigned char> >::_M_range_check (this=0x7fffffff38d0, __n=8024) at /usr/include/c++/11/bits/stl_vector.h:1072
1072		if (__n >= this->size())
1077	      }
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=8024) at /usr/include/c++/11/bits/stl_vector.h:1095
1095		return (*this)[__n];
std::vector<unsigned char, std::allocator<unsigned char> >::operator[] (this=0x7fffffff38d0, __n=8024) at /usr/include/c++/11/bits/stl_vector.h:1046
1046		return *(this->_M_impl._M_start + __n);
1047	      }
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=8024) at /usr/include/c++/11/bits/stl_vector.h:1096
1096	      }
Cartridge::readByte (this=0x7fffffff3860, address=8024) at /home/caidenmarley/gameboy/src/cartridge.cpp:160
160	        return romData.at(address);
168	}
Bus::read (this=0x7fffffff3910, address=8024) at /home/caidenmarley/gameboy/src/bus.cpp:24
24	        return cart.readByte(address);
82	}
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:58
58	    return decodeAndExecute(*this, bus, opcode);
decodeAndExecute (cpu=..., bus=..., opcode=224 '\340') at /home/caidenmarley/gameboy/include/instructions.h:93
93	    switch(opcode){
1701	                uint8_t offset = bus.read(cpu.PC++);
Bus::read (this=0x7fffffff3910, address=8025) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::read (this=0x7fffffff3910, address=8025) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
22	    if(address < 0x8000){
24	        return cart.readByte(address);
Cartridge::readByte (this=0x7fffffff3860, address=8025) at /home/caidenmarley/gameboy/src/cartridge.cpp:118
118	    if(isMbc2){
135	    if(isMbc1){
159	    if(address < 0x8000){
160	        return romData.at(address);
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=8025) at /usr/include/c++/11/bits/stl_vector.h:1094
1094		_M_range_check(__n);
std::vector<unsigned char, std::allocator<unsigned char> >::_M_range_check (this=0x7fffffff38d0, __n=8025) at /usr/include/c++/11/bits/stl_vector.h:1072
1072		if (__n >= this->size())
std::vector<unsigned char, std::allocator<unsigned char> >::size (this=0x7fffffff38d0) at /usr/include/c++/11/bits/stl_vector.h:919
919	      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
std::vector<unsigned char, std::allocator<unsigned char> >::_M_range_check (this=0x7fffffff38d0, __n=8025) at /usr/include/c++/11/bits/stl_vector.h:1072
1072		if (__n >= this->size())
1077	      }
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=8025) at /usr/include/c++/11/bits/stl_vector.h:1095
1095		return (*this)[__n];
std::vector<unsigned char, std::allocator<unsigned char> >::operator[] (this=0x7fffffff38d0, __n=8025) at /usr/include/c++/11/bits/stl_vector.h:1046
1046		return *(this->_M_impl._M_start + __n);
1047	      }
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=8025) at /usr/include/c++/11/bits/stl_vector.h:1096
1096	      }
Cartridge::readByte (this=0x7fffffff3860, address=8025) at /home/caidenmarley/gameboy/src/cartridge.cpp:160
160	        return romData.at(address);
168	}
Bus::read (this=0x7fffffff3910, address=8025) at /home/caidenmarley/gameboy/src/bus.cpp:24
24	        return cart.readByte(address);
82	}
decodeAndExecute (cpu=..., bus=..., opcode=224 '\340') at /home/caidenmarley/gameboy/include/instructions.h:1702
1702	                if ((0xFF00u + offset) == 0xFF40 || (0xFF00u + offset) == 0xFF41) {
1711	                bus.write(0xFF00 + offset, cpu.A);
Bus::write (this=0x7fffffff3910, address=65535, byte=0 '\000') at /home/caidenmarley/gameboy/src/bus.cpp:85
85	    if(address == 0xFF00){
89	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::write (this=0x7fffffff3910, address=65535, byte=0 '\000') at /home/caidenmarley/gameboy/src/bus.cpp:89
89	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
94	    if(address < 0x8000){
97	    }else if(address < 0xA000){
100	    }else if(address < 0xC000){
103	    }else if(address < 0xE000){
106	    }else if(address < 0xFE00){
109	    }else if(address < 0xFEA0){
112	    }else if(address < 0xFF00){
114	    }else if(address < 0xFF04){
117	    }else if(address < 0xFF08){
120	    }else if(address >= 0xFF40 && address <= 0xFF4B){
127	    }else if(address < 0xFF80){
130	    }else if(address < 0xFFFF){
135	        ieReg = byte;
137	}
decodeAndExecute (cpu=..., bus=..., opcode=224 '\340') at /home/caidenmarley/gameboy/include/instructions.h:1712
1712	                return 3;
1886	}
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:58
58	    return decodeAndExecute(*this, bus, opcode);
59	}
main (argc=2, argv=0x7fffffffd6e8) at /home/caidenmarley/gameboy/main.cpp:124
124	            bus.step(m * 4, cpu);
Bus::step (this=0x7fffffff3910, tStates=12, cpu=...) at /home/caidenmarley/gameboy/src/bus.cpp:140
140	    timer.step(tStates, cpu);
Timer::step (this=0x7fffffffb4a0, tStates=12, cpu=...) at /home/caidenmarley/gameboy/src/timer.cpp:8
8	    divCounter += tStates;
9	    while(divCounter >= 256){
15	    if(TAC & 0x04){
30	}
Bus::step (this=0x7fffffff3910, tStates=12, cpu=...) at /home/caidenmarley/gameboy/src/bus.cpp:141
141	    ppu.step(tStates, cpu);
PPU::step (this=0x7fffffff3910, tStates=12, cpu=...) at /home/caidenmarley/gameboy/src/ppu.cpp:17
17	void PPU::step(int tStates, CPU& cpu){
18	    stepDma(tStates);
PPU::stepDma (this=0x7fffffff3910, cycles=12) at /home/caidenmarley/gameboy/include/ppu.h:151
151	        if(!oamDmaActive) return;
156	    }
PPU::step (this=0x7fffffff3910, tStates=12, cpu=...) at /home/caidenmarley/gameboy/src/ppu.cpp:20
20	    if(!(LCDC & 0x80)){
24	    dotCounter += tStates;
27	        uint8_t mode = STAT & 0x03;
28	        int needed = 0;
30	        switch(mode){
46	            case 1: needed = 4560; break;
50	        if (dotCounter < needed){
51	            break;
142	}
Bus::step (this=0x7fffffff3910, tStates=12, cpu=...) at /home/caidenmarley/gameboy/src/bus.cpp:143
143	}
main (argc=2, argv=0x7fffffffd6e8) at /home/caidenmarley/gameboy/main.cpp:122
122	        while (!bus.ppu.isFrameReady()) {
PPU::isFrameReady (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:46
46	        return frameReady;
47	    }
main (argc=2, argv=0x7fffffffd6e8) at /home/caidenmarley/gameboy/main.cpp:122
122	        while (!bus.ppu.isFrameReady()) {
123	            int m = cpu.step();
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:10
10	    if(imeEnabledNextStep){
16	    if(stopped){
26	    if(halted){
35	    uint8_t ieaValue = bus.read(INTERRUPT_ENABLE_ADDRESS);
Bus::read (this=0x7fffffff3910, address=65535) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::read (this=0x7fffffff3910, address=65535) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
22	    if(address < 0x8000){
25	    }else if(address < 0xA000){
28	    }else if(address < 0xC000){
31	    }else if(address < 0xE000){
34	    }else if(address < 0xFE00){
37	    }else if(address < 0xFEA0){
40	    }else if(address < 0xFF00){
43	    }else if(address == 0xFF00){
63	    }else if(address < 0xFF04){
66	    }else if(address < 0xFF08){
69	    }else if(address >= 0xFF40 && address <= 0xFF4B){
72	    }else if(address < 0xFF80){
75	    }else if(address < 0xFFFF){
80	        return ieReg;
82	}
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:36
36	    uint8_t ifaValue = bus.read(INTERRUPT_FLAG_ADDRESS);
Bus::read (this=0x7fffffff3910, address=65295) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::read (this=0x7fffffff3910, address=65295) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
22	    if(address < 0x8000){
25	    }else if(address < 0xA000){
28	    }else if(address < 0xC000){
31	    }else if(address < 0xE000){
34	    }else if(address < 0xFE00){
37	    }else if(address < 0xFEA0){
40	    }else if(address < 0xFF00){
43	    }else if(address == 0xFF00){
63	    }else if(address < 0xFF04){
66	    }else if(address < 0xFF08){
69	    }else if(address >= 0xFF40 && address <= 0xFF4B){
72	    }else if(address < 0xFF80){
74	        return ioRegs[address - 0xFF00];
82	}
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:37
37	    uint8_t interruptRequest = ieaValue & ifaValue;
38	    if(IME && interruptRequest){
57	    uint8_t opcode = bus.read(PC++);
Bus::read (this=0x7fffffff3910, address=8026) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::read (this=0x7fffffff3910, address=8026) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
22	    if(address < 0x8000){
24	        return cart.readByte(address);
Cartridge::readByte (this=0x7fffffff3860, address=8026) at /home/caidenmarley/gameboy/src/cartridge.cpp:118
118	    if(isMbc2){
135	    if(isMbc1){
159	    if(address < 0x8000){
160	        return romData.at(address);
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=8026) at /usr/include/c++/11/bits/stl_vector.h:1094
1094		_M_range_check(__n);
std::vector<unsigned char, std::allocator<unsigned char> >::_M_range_check (this=0x7fffffff38d0, __n=8026) at /usr/include/c++/11/bits/stl_vector.h:1072
1072		if (__n >= this->size())
std::vector<unsigned char, std::allocator<unsigned char> >::size (this=0x7fffffff38d0) at /usr/include/c++/11/bits/stl_vector.h:919
919	      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
std::vector<unsigned char, std::allocator<unsigned char> >::_M_range_check (this=0x7fffffff38d0, __n=8026) at /usr/include/c++/11/bits/stl_vector.h:1072
1072		if (__n >= this->size())
1077	      }
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=8026) at /usr/include/c++/11/bits/stl_vector.h:1095
1095		return (*this)[__n];
std::vector<unsigned char, std::allocator<unsigned char> >::operator[] (this=0x7fffffff38d0, __n=8026) at /usr/include/c++/11/bits/stl_vector.h:1046
1046		return *(this->_M_impl._M_start + __n);
1047	      }
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=8026) at /usr/include/c++/11/bits/stl_vector.h:1096
1096	      }
Cartridge::readByte (this=0x7fffffff3860, address=8026) at /home/caidenmarley/gameboy/src/cartridge.cpp:160
160	        return romData.at(address);
168	}
Bus::read (this=0x7fffffff3910, address=8026) at /home/caidenmarley/gameboy/src/bus.cpp:24
24	        return cart.readByte(address);
82	}
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:58
58	    return decodeAndExecute(*this, bus, opcode);
decodeAndExecute (cpu=..., bus=..., opcode=224 '\340') at /home/caidenmarley/gameboy/include/instructions.h:93
93	    switch(opcode){
1701	                uint8_t offset = bus.read(cpu.PC++);
Bus::read (this=0x7fffffff3910, address=8027) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::read (this=0x7fffffff3910, address=8027) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
22	    if(address < 0x8000){
24	        return cart.readByte(address);
Cartridge::readByte (this=0x7fffffff3860, address=8027) at /home/caidenmarley/gameboy/src/cartridge.cpp:118
118	    if(isMbc2){
135	    if(isMbc1){
159	    if(address < 0x8000){
160	        return romData.at(address);
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=8027) at /usr/include/c++/11/bits/stl_vector.h:1094
1094		_M_range_check(__n);
std::vector<unsigned char, std::allocator<unsigned char> >::_M_range_check (this=0x7fffffff38d0, __n=8027) at /usr/include/c++/11/bits/stl_vector.h:1072
1072		if (__n >= this->size())
std::vector<unsigned char, std::allocator<unsigned char> >::size (this=0x7fffffff38d0) at /usr/include/c++/11/bits/stl_vector.h:919
919	      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
std::vector<unsigned char, std::allocator<unsigned char> >::_M_range_check (this=0x7fffffff38d0, __n=8027) at /usr/include/c++/11/bits/stl_vector.h:1072
1072		if (__n >= this->size())
1077	      }
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=8027) at /usr/include/c++/11/bits/stl_vector.h:1095
1095		return (*this)[__n];
std::vector<unsigned char, std::allocator<unsigned char> >::operator[] (this=0x7fffffff38d0, __n=8027) at /usr/include/c++/11/bits/stl_vector.h:1046
1046		return *(this->_M_impl._M_start + __n);
1047	      }
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=8027) at /usr/include/c++/11/bits/stl_vector.h:1096
1096	      }
Cartridge::readByte (this=0x7fffffff3860, address=8027) at /home/caidenmarley/gameboy/src/cartridge.cpp:160
160	        return romData.at(address);
168	}
Bus::read (this=0x7fffffff3910, address=8027) at /home/caidenmarley/gameboy/src/bus.cpp:24
24	        return cart.readByte(address);
82	}
decodeAndExecute (cpu=..., bus=..., opcode=224 '\340') at /home/caidenmarley/gameboy/include/instructions.h:1702
1702	                if ((0xFF00u + offset) == 0xFF40 || (0xFF00u + offset) == 0xFF41) {
1711	                bus.write(0xFF00 + offset, cpu.A);
Bus::write (this=0x7fffffff3910, address=65347, byte=0 '\000') at /home/caidenmarley/gameboy/src/bus.cpp:85
85	    if(address == 0xFF00){
89	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::write (this=0x7fffffff3910, address=65347, byte=0 '\000') at /home/caidenmarley/gameboy/src/bus.cpp:89
89	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
94	    if(address < 0x8000){
97	    }else if(address < 0xA000){
$6 = 0x91
100	    }else if(address < 0xC000){
103	    }else if(address < 0xE000){
106	    }else if(address < 0xFE00){
109	    }else if(address < 0xFEA0){
112	    }else if(address < 0xFF00){
114	    }else if(address < 0xFF04){
117	    }else if(address < 0xFF08){
120	    }else if(address >= 0xFF40 && address <= 0xFF4B){
122	        std::cout << "here2" << std::endl;
123	        if(address == 0xFF40){
126	        ppu.write(address, byte);
PPU::write (this=0x7fffffff3910, address=65347, byte=0 '\000') at /home/caidenmarley/gameboy/src/ppu.cpp:182
182	    if(address == 0xFF46){
194	    if(address >= 0x8000 && address <= 0x9FFF){
203	    if(address >= 0xFE00 && address <= 0xFE9F){
210	    if(address == 0xFF40){
214	    switch(address){
233	        case SCX_ADDRESS: SCX = byte; break;
243	}
Bus::write (this=0x7fffffff3910, address=65347, byte=0 '\000') at /home/caidenmarley/gameboy/src/bus.cpp:137
137	}
decodeAndExecute (cpu=..., bus=..., opcode=224 '\340') at /home/caidenmarley/gameboy/include/instructions.h:1712
1712	                return 3;
1886	}
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:58
58	    return decodeAndExecute(*this, bus, opcode);
59	}
main (argc=2, argv=0x7fffffffd6e8) at /home/caidenmarley/gameboy/main.cpp:124
124	            bus.step(m * 4, cpu);
Bus::step (this=0x7fffffff3910, tStates=12, cpu=...) at /home/caidenmarley/gameboy/src/bus.cpp:140
140	    timer.step(tStates, cpu);
Timer::step (this=0x7fffffffb4a0, tStates=12, cpu=...) at /home/caidenmarley/gameboy/src/timer.cpp:8
8	    divCounter += tStates;
9	    while(divCounter >= 256){
15	    if(TAC & 0x04){
30	}
Bus::step (this=0x7fffffff3910, tStates=12, cpu=...) at /home/caidenmarley/gameboy/src/bus.cpp:141
141	    ppu.step(tStates, cpu);
PPU::step (this=0x7fffffff3910, tStates=12, cpu=...) at /home/caidenmarley/gameboy/src/ppu.cpp:17
17	void PPU::step(int tStates, CPU& cpu){
18	    stepDma(tStates);
PPU::stepDma (this=0x7fffffff3910, cycles=12) at /home/caidenmarley/gameboy/include/ppu.h:151
151	        if(!oamDmaActive) return;
156	    }
PPU::step (this=0x7fffffff3910, tStates=12, cpu=...) at /home/caidenmarley/gameboy/src/ppu.cpp:20
20	    if(!(LCDC & 0x80)){
24	    dotCounter += tStates;
27	        uint8_t mode = STAT & 0x03;
28	        int needed = 0;
30	        switch(mode){
46	            case 1: needed = 4560; break;
50	        if (dotCounter < needed){
51	            break;
142	}
Bus::step (this=0x7fffffff3910, tStates=12, cpu=...) at /home/caidenmarley/gameboy/src/bus.cpp:143
143	}
main (argc=2, argv=0x7fffffffd6e8) at /home/caidenmarley/gameboy/main.cpp:122
122	        while (!bus.ppu.isFrameReady()) {
PPU::isFrameReady (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:46
46	        return frameReady;
47	    }
main (argc=2, argv=0x7fffffffd6e8) at /home/caidenmarley/gameboy/main.cpp:122
122	        while (!bus.ppu.isFrameReady()) {
123	            int m = cpu.step();
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:10
10	    if(imeEnabledNextStep){
16	    if(stopped){
26	    if(halted){
35	    uint8_t ieaValue = bus.read(INTERRUPT_ENABLE_ADDRESS);
Bus::read (this=0x7fffffff3910, address=65535) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::read (this=0x7fffffff3910, address=65535) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
22	    if(address < 0x8000){
25	    }else if(address < 0xA000){
28	    }else if(address < 0xC000){
31	    }else if(address < 0xE000){
34	    }else if(address < 0xFE00){
37	    }else if(address < 0xFEA0){
40	    }else if(address < 0xFF00){
43	    }else if(address == 0xFF00){
63	    }else if(address < 0xFF04){
66	    }else if(address < 0xFF08){
69	    }else if(address >= 0xFF40 && address <= 0xFF4B){
72	    }else if(address < 0xFF80){
75	    }else if(address < 0xFFFF){
80	        return ieReg;
82	}
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:36
36	    uint8_t ifaValue = bus.read(INTERRUPT_FLAG_ADDRESS);
Bus::read (this=0x7fffffff3910, address=65295) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::read (this=0x7fffffff3910, address=65295) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
22	    if(address < 0x8000){
25	    }else if(address < 0xA000){
28	    }else if(address < 0xC000){
31	    }else if(address < 0xE000){
34	    }else if(address < 0xFE00){
37	    }else if(address < 0xFEA0){
40	    }else if(address < 0xFF00){
43	    }else if(address == 0xFF00){
63	    }else if(address < 0xFF04){
66	    }else if(address < 0xFF08){
69	    }else if(address >= 0xFF40 && address <= 0xFF4B){
72	    }else if(address < 0xFF80){
74	        return ioRegs[address - 0xFF00];
82	}
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:37
37	    uint8_t interruptRequest = ieaValue & ifaValue;
38	    if(IME && interruptRequest){
57	    uint8_t opcode = bus.read(PC++);
Bus::read (this=0x7fffffff3910, address=8028) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::read (this=0x7fffffff3910, address=8028) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
22	    if(address < 0x8000){
24	        return cart.readByte(address);
Cartridge::readByte (this=0x7fffffff3860, address=8028) at /home/caidenmarley/gameboy/src/cartridge.cpp:118
118	    if(isMbc2){
135	    if(isMbc1){
159	    if(address < 0x8000){
160	        return romData.at(address);
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=8028) at /usr/include/c++/11/bits/stl_vector.h:1094
1094		_M_range_check(__n);
std::vector<unsigned char, std::allocator<unsigned char> >::_M_range_check (this=0x7fffffff38d0, __n=8028) at /usr/include/c++/11/bits/stl_vector.h:1072
1072		if (__n >= this->size())
std::vector<unsigned char, std::allocator<unsigned char> >::size (this=0x7fffffff38d0) at /usr/include/c++/11/bits/stl_vector.h:919
919	      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
std::vector<unsigned char, std::allocator<unsigned char> >::_M_range_check (this=0x7fffffff38d0, __n=8028) at /usr/include/c++/11/bits/stl_vector.h:1072
1072		if (__n >= this->size())
1077	      }
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=8028) at /usr/include/c++/11/bits/stl_vector.h:1095
1095		return (*this)[__n];
std::vector<unsigned char, std::allocator<unsigned char> >::operator[] (this=0x7fffffff38d0, __n=8028) at /usr/include/c++/11/bits/stl_vector.h:1046
1046		return *(this->_M_impl._M_start + __n);
1047	      }
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=8028) at /usr/include/c++/11/bits/stl_vector.h:1096
1096	      }
Cartridge::readByte (this=0x7fffffff3860, address=8028) at /home/caidenmarley/gameboy/src/cartridge.cpp:160
160	        return romData.at(address);
168	}
Bus::read (this=0x7fffffff3910, address=8028) at /home/caidenmarley/gameboy/src/bus.cpp:24
24	        return cart.readByte(address);
82	}
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:58
58	    return decodeAndExecute(*this, bus, opcode);
decodeAndExecute (cpu=..., bus=..., opcode=224 '\340') at /home/caidenmarley/gameboy/include/instructions.h:93
93	    switch(opcode){
1701	                uint8_t offset = bus.read(cpu.PC++);
Bus::read (this=0x7fffffff3910, address=8029) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::read (this=0x7fffffff3910, address=8029) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
22	    if(address < 0x8000){
24	        return cart.readByte(address);
Cartridge::readByte (this=0x7fffffff3860, address=8029) at /home/caidenmarley/gameboy/src/cartridge.cpp:118
118	    if(isMbc2){
135	    if(isMbc1){
159	    if(address < 0x8000){
160	        return romData.at(address);
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=8029) at /usr/include/c++/11/bits/stl_vector.h:1094
1094		_M_range_check(__n);
std::vector<unsigned char, std::allocator<unsigned char> >::_M_range_check (this=0x7fffffff38d0, __n=8029) at /usr/include/c++/11/bits/stl_vector.h:1072
1072		if (__n >= this->size())
std::vector<unsigned char, std::allocator<unsigned char> >::size (this=0x7fffffff38d0) at /usr/include/c++/11/bits/stl_vector.h:919
919	      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
std::vector<unsigned char, std::allocator<unsigned char> >::_M_range_check (this=0x7fffffff38d0, __n=8029) at /usr/include/c++/11/bits/stl_vector.h:1072
1072		if (__n >= this->size())
1077	      }
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=8029) at /usr/include/c++/11/bits/stl_vector.h:1095
1095		return (*this)[__n];
std::vector<unsigned char, std::allocator<unsigned char> >::operator[] (this=0x7fffffff38d0, __n=8029) at /usr/include/c++/11/bits/stl_vector.h:1046
1046		return *(this->_M_impl._M_start + __n);
1047	      }
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=8029) at /usr/include/c++/11/bits/stl_vector.h:1096
1096	      }
Cartridge::readByte (this=0x7fffffff3860, address=8029) at /home/caidenmarley/gameboy/src/cartridge.cpp:160
160	        return romData.at(address);
168	}
Bus::read (this=0x7fffffff3910, address=8029) at /home/caidenmarley/gameboy/src/bus.cpp:24
24	        return cart.readByte(address);
82	}
decodeAndExecute (cpu=..., bus=..., opcode=224 '\340') at /home/caidenmarley/gameboy/include/instructions.h:1702
1702	                if ((0xFF00u + offset) == 0xFF40 || (0xFF00u + offset) == 0xFF41) {
1711	                bus.write(0xFF00 + offset, cpu.A);
Bus::write (this=0x7fffffff3910, address=65346, byte=0 '\000') at /home/caidenmarley/gameboy/src/bus.cpp:85
85	    if(address == 0xFF00){
89	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::write (this=0x7fffffff3910, address=65346, byte=0 '\000') at /home/caidenmarley/gameboy/src/bus.cpp:89
89	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
94	    if(address < 0x8000){
97	    }else if(address < 0xA000){
100	    }else if(address < 0xC000){
103	    }else if(address < 0xE000){
106	    }else if(address < 0xFE00){
109	    }else if(address < 0xFEA0){
112	    }else if(address < 0xFF00){
114	    }else if(address < 0xFF04){
117	    }else if(address < 0xFF08){
120	    }else if(address >= 0xFF40 && address <= 0xFF4B){
122	        std::cout << "here2" << std::endl;
123	        if(address == 0xFF40){
126	        ppu.write(address, byte);
PPU::write (this=0x7fffffff3910, address=65346, byte=0 '\000') at /home/caidenmarley/gameboy/src/ppu.cpp:182
182	    if(address == 0xFF46){
194	    if(address >= 0x8000 && address <= 0x9FFF){
203	    if(address >= 0xFE00 && address <= 0xFE9F){
210	    if(address == 0xFF40){
214	    switch(address){
232	        case SCY_ADDRESS: SCY = byte; break;
243	}
Bus::write (this=0x7fffffff3910, address=65346, byte=0 '\000') at /home/caidenmarley/gameboy/src/bus.cpp:137
137	}
decodeAndExecute (cpu=..., bus=..., opcode=224 '\340') at /home/caidenmarley/gameboy/include/instructions.h:1712
1712	                return 3;
1886	}
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:58
58	    return decodeAndExecute(*this, bus, opcode);
59	}
main (argc=2, argv=0x7fffffffd6e8) at /home/caidenmarley/gameboy/main.cpp:124
124	            bus.step(m * 4, cpu);
Bus::step (this=0x7fffffff3910, tStates=12, cpu=...) at /home/caidenmarley/gameboy/src/bus.cpp:140
140	    timer.step(tStates, cpu);
Timer::step (this=0x7fffffffb4a0, tStates=12, cpu=...) at /home/caidenmarley/gameboy/src/timer.cpp:8
8	    divCounter += tStates;
9	    while(divCounter >= 256){
15	    if(TAC & 0x04){
30	}
Bus::step (this=0x7fffffff3910, tStates=12, cpu=...) at /home/caidenmarley/gameboy/src/bus.cpp:141
141	    ppu.step(tStates, cpu);
PPU::step (this=0x7fffffff3910, tStates=12, cpu=...) at /home/caidenmarley/gameboy/src/ppu.cpp:17
17	void PPU::step(int tStates, CPU& cpu){
18	    stepDma(tStates);
PPU::stepDma (this=0x7fffffff3910, cycles=12) at /home/caidenmarley/gameboy/include/ppu.h:151
151	        if(!oamDmaActive) return;
156	    }
PPU::step (this=0x7fffffff3910, tStates=12, cpu=...) at /home/caidenmarley/gameboy/src/ppu.cpp:20
20	    if(!(LCDC & 0x80)){
24	    dotCounter += tStates;
27	        uint8_t mode = STAT & 0x03;
28	        int needed = 0;
30	        switch(mode){
46	            case 1: needed = 4560; break;
50	        if (dotCounter < needed){
51	            break;
142	}
Bus::step (this=0x7fffffff3910, tStates=12, cpu=...) at /home/caidenmarley/gameboy/src/bus.cpp:143
143	}
main (argc=2, argv=0x7fffffffd6e8) at /home/caidenmarley/gameboy/main.cpp:122
122	        while (!bus.ppu.isFrameReady()) {
PPU::isFrameReady (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:46
46	        return frameReady;
47	    }
main (argc=2, argv=0x7fffffffd6e8) at /home/caidenmarley/gameboy/main.cpp:122
122	        while (!bus.ppu.isFrameReady()) {
123	            int m = cpu.step();
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:10
10	    if(imeEnabledNextStep){
16	    if(stopped){
26	    if(halted){
35	    uint8_t ieaValue = bus.read(INTERRUPT_ENABLE_ADDRESS);
Bus::read (this=0x7fffffff3910, address=65535) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::read (this=0x7fffffff3910, address=65535) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
22	    if(address < 0x8000){
25	    }else if(address < 0xA000){
28	    }else if(address < 0xC000){
31	    }else if(address < 0xE000){
34	    }else if(address < 0xFE00){
37	    }else if(address < 0xFEA0){
40	    }else if(address < 0xFF00){
43	    }else if(address == 0xFF00){
63	    }else if(address < 0xFF04){
66	    }else if(address < 0xFF08){
69	    }else if(address >= 0xFF40 && address <= 0xFF4B){
72	    }else if(address < 0xFF80){
75	    }else if(address < 0xFFFF){
80	        return ieReg;
82	}
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:36
36	    uint8_t ifaValue = bus.read(INTERRUPT_FLAG_ADDRESS);
Bus::read (this=0x7fffffff3910, address=65295) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::read (this=0x7fffffff3910, address=65295) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
22	    if(address < 0x8000){
25	    }else if(address < 0xA000){
28	    }else if(address < 0xC000){
31	    }else if(address < 0xE000){
34	    }else if(address < 0xFE00){
37	    }else if(address < 0xFEA0){
40	    }else if(address < 0xFF00){
43	    }else if(address == 0xFF00){
63	    }else if(address < 0xFF04){
66	    }else if(address < 0xFF08){
69	    }else if(address >= 0xFF40 && address <= 0xFF4B){
72	    }else if(address < 0xFF80){
74	        return ioRegs[address - 0xFF00];
82	}
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:37
37	    uint8_t interruptRequest = ieaValue & ifaValue;
38	    if(IME && interruptRequest){
57	    uint8_t opcode = bus.read(PC++);
Bus::read (this=0x7fffffff3910, address=8030) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::read (this=0x7fffffff3910, address=8030) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
22	    if(address < 0x8000){
24	        return cart.readByte(address);
Cartridge::readByte (this=0x7fffffff3860, address=8030) at /home/caidenmarley/gameboy/src/cartridge.cpp:118
118	    if(isMbc2){
135	    if(isMbc1){
159	    if(address < 0x8000){
160	        return romData.at(address);
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=8030) at /usr/include/c++/11/bits/stl_vector.h:1094
1094		_M_range_check(__n);
std::vector<unsigned char, std::allocator<unsigned char> >::_M_range_check (this=0x7fffffff38d0, __n=8030) at /usr/include/c++/11/bits/stl_vector.h:1072
1072		if (__n >= this->size())
std::vector<unsigned char, std::allocator<unsigned char> >::size (this=0x7fffffff38d0) at /usr/include/c++/11/bits/stl_vector.h:919
919	      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
std::vector<unsigned char, std::allocator<unsigned char> >::_M_range_check (this=0x7fffffff38d0, __n=8030) at /usr/include/c++/11/bits/stl_vector.h:1072
1072		if (__n >= this->size())
1077	      }
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=8030) at /usr/include/c++/11/bits/stl_vector.h:1095
1095		return (*this)[__n];
std::vector<unsigned char, std::allocator<unsigned char> >::operator[] (this=0x7fffffff38d0, __n=8030) at /usr/include/c++/11/bits/stl_vector.h:1046
1046		return *(this->_M_impl._M_start + __n);
1047	      }
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=8030) at /usr/include/c++/11/bits/stl_vector.h:1096
1096	      }
Cartridge::readByte (this=0x7fffffff3860, address=8030) at /home/caidenmarley/gameboy/src/cartridge.cpp:160
160	        return romData.at(address);
168	}
Bus::read (this=0x7fffffff3910, address=8030) at /home/caidenmarley/gameboy/src/bus.cpp:24
24	        return cart.readByte(address);
82	}
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:58
58	    return decodeAndExecute(*this, bus, opcode);
decodeAndExecute (cpu=..., bus=..., opcode=224 '\340') at /home/caidenmarley/gameboy/include/instructions.h:93
93	    switch(opcode){
1701	                uint8_t offset = bus.read(cpu.PC++);
Bus::read (this=0x7fffffff3910, address=8031) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::read (this=0x7fffffff3910, address=8031) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
22	    if(address < 0x8000){
24	        return cart.readByte(address);
Cartridge::readByte (this=0x7fffffff3860, address=8031) at /home/caidenmarley/gameboy/src/cartridge.cpp:118
118	    if(isMbc2){
135	    if(isMbc1){
159	    if(address < 0x8000){
160	        return romData.at(address);
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=8031) at /usr/include/c++/11/bits/stl_vector.h:1094
1094		_M_range_check(__n);
std::vector<unsigned char, std::allocator<unsigned char> >::_M_range_check (this=0x7fffffff38d0, __n=8031) at /usr/include/c++/11/bits/stl_vector.h:1072
1072		if (__n >= this->size())
std::vector<unsigned char, std::allocator<unsigned char> >::size (this=0x7fffffff38d0) at /usr/include/c++/11/bits/stl_vector.h:919
919	      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
std::vector<unsigned char, std::allocator<unsigned char> >::_M_range_check (this=0x7fffffff38d0, __n=8031) at /usr/include/c++/11/bits/stl_vector.h:1072
1072		if (__n >= this->size())
1077	      }
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=8031) at /usr/include/c++/11/bits/stl_vector.h:1095
1095		return (*this)[__n];
std::vector<unsigned char, std::allocator<unsigned char> >::operator[] (this=0x7fffffff38d0, __n=8031) at /usr/include/c++/11/bits/stl_vector.h:1046
1046		return *(this->_M_impl._M_start + __n);
1047	      }
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=8031) at /usr/include/c++/11/bits/stl_vector.h:1096
1096	      }
Cartridge::readByte (this=0x7fffffff3860, address=8031) at /home/caidenmarley/gameboy/src/cartridge.cpp:160
160	        return romData.at(address);
168	}
Bus::read (this=0x7fffffff3910, address=8031) at /home/caidenmarley/gameboy/src/bus.cpp:24
24	        return cart.readByte(address);
82	}
decodeAndExecute (cpu=..., bus=..., opcode=224 '\340') at /home/caidenmarley/gameboy/include/instructions.h:1702
1702	                if ((0xFF00u + offset) == 0xFF40 || (0xFF00u + offset) == 0xFF41) {
1711	                bus.write(0xFF00 + offset, cpu.A);
Bus::write (this=0x7fffffff3910, address=65281, byte=0 '\000') at /home/caidenmarley/gameboy/src/bus.cpp:85
85	    if(address == 0xFF00){
89	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::write (this=0x7fffffff3910, address=65281, byte=0 '\000') at /home/caidenmarley/gameboy/src/bus.cpp:89
89	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
94	    if(address < 0x8000){
97	    }else if(address < 0xA000){
100	    }else if(address < 0xC000){
103	    }else if(address < 0xE000){
106	    }else if(address < 0xFE00){
109	    }else if(address < 0xFEA0){
112	    }else if(address < 0xFF00){
114	    }else if(address < 0xFF04){
116	        ioRegs[address - 0xFF00] = byte;
137	}
decodeAndExecute (cpu=..., bus=..., opcode=224 '\340') at /home/caidenmarley/gameboy/include/instructions.h:1712
1712	                return 3;
1886	}
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:58
58	    return decodeAndExecute(*this, bus, opcode);
59	}
main (argc=2, argv=0x7fffffffd6e8) at /home/caidenmarley/gameboy/main.cpp:124
124	            bus.step(m * 4, cpu);
Bus::step (this=0x7fffffff3910, tStates=12, cpu=...) at /home/caidenmarley/gameboy/src/bus.cpp:140
140	    timer.step(tStates, cpu);
Timer::step (this=0x7fffffffb4a0, tStates=12, cpu=...) at /home/caidenmarley/gameboy/src/timer.cpp:8
8	    divCounter += tStates;
9	    while(divCounter >= 256){
15	    if(TAC & 0x04){
30	}
Bus::step (this=0x7fffffff3910, tStates=12, cpu=...) at /home/caidenmarley/gameboy/src/bus.cpp:141
141	    ppu.step(tStates, cpu);
PPU::step (this=0x7fffffff3910, tStates=12, cpu=...) at /home/caidenmarley/gameboy/src/ppu.cpp:17
17	void PPU::step(int tStates, CPU& cpu){
18	    stepDma(tStates);
PPU::stepDma (this=0x7fffffff3910, cycles=12) at /home/caidenmarley/gameboy/include/ppu.h:151
151	        if(!oamDmaActive) return;
156	    }
PPU::step (this=0x7fffffff3910, tStates=12, cpu=...) at /home/caidenmarley/gameboy/src/ppu.cpp:20
20	    if(!(LCDC & 0x80)){
24	    dotCounter += tStates;
27	        uint8_t mode = STAT & 0x03;
28	        int needed = 0;
30	        switch(mode){
46	            case 1: needed = 4560; break;
50	        if (dotCounter < needed){
51	            break;
142	}
Bus::step (this=0x7fffffff3910, tStates=12, cpu=...) at /home/caidenmarley/gameboy/src/bus.cpp:143
143	}
main (argc=2, argv=0x7fffffffd6e8) at /home/caidenmarley/gameboy/main.cpp:122
122	        while (!bus.ppu.isFrameReady()) {
PPU::isFrameReady (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:46
46	        return frameReady;
47	    }
main (argc=2, argv=0x7fffffffd6e8) at /home/caidenmarley/gameboy/main.cpp:122
122	        while (!bus.ppu.isFrameReady()) {
123	            int m = cpu.step();
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:10
10	    if(imeEnabledNextStep){
16	    if(stopped){
26	    if(halted){
35	    uint8_t ieaValue = bus.read(INTERRUPT_ENABLE_ADDRESS);
Bus::read (this=0x7fffffff3910, address=65535) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::read (this=0x7fffffff3910, address=65535) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
22	    if(address < 0x8000){
25	    }else if(address < 0xA000){
28	    }else if(address < 0xC000){
31	    }else if(address < 0xE000){
34	    }else if(address < 0xFE00){
37	    }else if(address < 0xFEA0){
40	    }else if(address < 0xFF00){
43	    }else if(address == 0xFF00){
63	    }else if(address < 0xFF04){
66	    }else if(address < 0xFF08){
69	    }else if(address >= 0xFF40 && address <= 0xFF4B){
72	    }else if(address < 0xFF80){
75	    }else if(address < 0xFFFF){
80	        return ieReg;
82	}
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:36
36	    uint8_t ifaValue = bus.read(INTERRUPT_FLAG_ADDRESS);
Bus::read (this=0x7fffffff3910, address=65295) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::read (this=0x7fffffff3910, address=65295) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
22	    if(address < 0x8000){
25	    }else if(address < 0xA000){
28	    }else if(address < 0xC000){
31	    }else if(address < 0xE000){
34	    }else if(address < 0xFE00){
37	    }else if(address < 0xFEA0){
40	    }else if(address < 0xFF00){
43	    }else if(address == 0xFF00){
63	    }else if(address < 0xFF04){
66	    }else if(address < 0xFF08){
69	    }else if(address >= 0xFF40 && address <= 0xFF4B){
72	    }else if(address < 0xFF80){
74	        return ioRegs[address - 0xFF00];
82	}
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:37
37	    uint8_t interruptRequest = ieaValue & ifaValue;
38	    if(IME && interruptRequest){
57	    uint8_t opcode = bus.read(PC++);
Bus::read (this=0x7fffffff3910, address=8032) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::read (this=0x7fffffff3910, address=8032) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
22	    if(address < 0x8000){
24	        return cart.readByte(address);
Cartridge::readByte (this=0x7fffffff3860, address=8032) at /home/caidenmarley/gameboy/src/cartridge.cpp:118
118	    if(isMbc2){
135	    if(isMbc1){
159	    if(address < 0x8000){
160	        return romData.at(address);
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=8032) at /usr/include/c++/11/bits/stl_vector.h:1094
1094		_M_range_check(__n);
std::vector<unsigned char, std::allocator<unsigned char> >::_M_range_check (this=0x7fffffff38d0, __n=8032) at /usr/include/c++/11/bits/stl_vector.h:1072
1072		if (__n >= this->size())
std::vector<unsigned char, std::allocator<unsigned char> >::size (this=0x7fffffff38d0) at /usr/include/c++/11/bits/stl_vector.h:919
919	      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
std::vector<unsigned char, std::allocator<unsigned char> >::_M_range_check (this=0x7fffffff38d0, __n=8032) at /usr/include/c++/11/bits/stl_vector.h:1072
1072		if (__n >= this->size())
1077	      }
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=8032) at /usr/include/c++/11/bits/stl_vector.h:1095
1095		return (*this)[__n];
std::vector<unsigned char, std::allocator<unsigned char> >::operator[] (this=0x7fffffff38d0, __n=8032) at /usr/include/c++/11/bits/stl_vector.h:1046
1046		return *(this->_M_impl._M_start + __n);
1047	      }
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=8032) at /usr/include/c++/11/bits/stl_vector.h:1096
1096	      }
Cartridge::readByte (this=0x7fffffff3860, address=8032) at /home/caidenmarley/gameboy/src/cartridge.cpp:160
160	        return romData.at(address);
168	}
Bus::read (this=0x7fffffff3910, address=8032) at /home/caidenmarley/gameboy/src/bus.cpp:24
24	        return cart.readByte(address);
82	}
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:58
58	    return decodeAndExecute(*this, bus, opcode);
decodeAndExecute (cpu=..., bus=..., opcode=224 '\340') at /home/caidenmarley/gameboy/include/instructions.h:93
93	    switch(opcode){
1701	                uint8_t offset = bus.read(cpu.PC++);
Bus::read (this=0x7fffffff3910, address=8033) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::read (this=0x7fffffff3910, address=8033) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
22	    if(address < 0x8000){
24	        return cart.readByte(address);
$7 = 0x91
$8 = 0x91
Cartridge::readByte (this=0x7fffffff3860, address=8033) at /home/caidenmarley/gameboy/src/cartridge.cpp:118
118	    if(isMbc2){
135	    if(isMbc1){
159	    if(address < 0x8000){
160	        return romData.at(address);
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=8033) at /usr/include/c++/11/bits/stl_vector.h:1094
1094		_M_range_check(__n);
std::vector<unsigned char, std::allocator<unsigned char> >::_M_range_check (this=0x7fffffff38d0, __n=8033) at /usr/include/c++/11/bits/stl_vector.h:1072
1072		if (__n >= this->size())
std::vector<unsigned char, std::allocator<unsigned char> >::size (this=0x7fffffff38d0) at /usr/include/c++/11/bits/stl_vector.h:919
919	      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
std::vector<unsigned char, std::allocator<unsigned char> >::_M_range_check (this=0x7fffffff38d0, __n=8033) at /usr/include/c++/11/bits/stl_vector.h:1072
1072		if (__n >= this->size())
1077	      }
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=8033) at /usr/include/c++/11/bits/stl_vector.h:1095
1095		return (*this)[__n];
std::vector<unsigned char, std::allocator<unsigned char> >::operator[] (this=0x7fffffff38d0, __n=8033) at /usr/include/c++/11/bits/stl_vector.h:1046
1046		return *(this->_M_impl._M_start + __n);
1047	      }
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=8033) at /usr/include/c++/11/bits/stl_vector.h:1096
1096	      }
Cartridge::readByte (this=0x7fffffff3860, address=8033) at /home/caidenmarley/gameboy/src/cartridge.cpp:160
160	        return romData.at(address);
168	}
Bus::read (this=0x7fffffff3910, address=8033) at /home/caidenmarley/gameboy/src/bus.cpp:24
24	        return cart.readByte(address);
82	}
decodeAndExecute (cpu=..., bus=..., opcode=224 '\340') at /home/caidenmarley/gameboy/include/instructions.h:1702
1702	                if ((0xFF00u + offset) == 0xFF40 || (0xFF00u + offset) == 0xFF41) {
1711	                bus.write(0xFF00 + offset, cpu.A);
Bus::write (this=0x7fffffff3910, address=65282, byte=0 '\000') at /home/caidenmarley/gameboy/src/bus.cpp:85
85	    if(address == 0xFF00){
89	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::write (this=0x7fffffff3910, address=65282, byte=0 '\000') at /home/caidenmarley/gameboy/src/bus.cpp:89
89	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
94	    if(address < 0x8000){
97	    }else if(address < 0xA000){
100	    }else if(address < 0xC000){
103	    }else if(address < 0xE000){
106	    }else if(address < 0xFE00){
109	    }else if(address < 0xFEA0){
112	    }else if(address < 0xFF00){
114	    }else if(address < 0xFF04){
116	        ioRegs[address - 0xFF00] = byte;
137	}
decodeAndExecute (cpu=..., bus=..., opcode=224 '\340') at /home/caidenmarley/gameboy/include/instructions.h:1712
1712	                return 3;
1886	}
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:58
58	    return decodeAndExecute(*this, bus, opcode);
59	}
main (argc=2, argv=0x7fffffffd6e8) at /home/caidenmarley/gameboy/main.cpp:124
124	            bus.step(m * 4, cpu);
Bus::step (this=0x7fffffff3910, tStates=12, cpu=...) at /home/caidenmarley/gameboy/src/bus.cpp:140
140	    timer.step(tStates, cpu);
Timer::step (this=0x7fffffffb4a0, tStates=12, cpu=...) at /home/caidenmarley/gameboy/src/timer.cpp:8
8	    divCounter += tStates;
9	    while(divCounter >= 256){
15	    if(TAC & 0x04){
30	}
Bus::step (this=0x7fffffff3910, tStates=12, cpu=...) at /home/caidenmarley/gameboy/src/bus.cpp:141
141	    ppu.step(tStates, cpu);
PPU::step (this=0x7fffffff3910, tStates=12, cpu=...) at /home/caidenmarley/gameboy/src/ppu.cpp:17
17	void PPU::step(int tStates, CPU& cpu){
18	    stepDma(tStates);
PPU::stepDma (this=0x7fffffff3910, cycles=12) at /home/caidenmarley/gameboy/include/ppu.h:151
151	        if(!oamDmaActive) return;
156	    }
PPU::step (this=0x7fffffff3910, tStates=12, cpu=...) at /home/caidenmarley/gameboy/src/ppu.cpp:20
20	    if(!(LCDC & 0x80)){
24	    dotCounter += tStates;
27	        uint8_t mode = STAT & 0x03;
28	        int needed = 0;
30	        switch(mode){
46	            case 1: needed = 4560; break;
50	        if (dotCounter < needed){
51	            break;
142	}
Bus::step (this=0x7fffffff3910, tStates=12, cpu=...) at /home/caidenmarley/gameboy/src/bus.cpp:143
143	}
main (argc=2, argv=0x7fffffffd6e8) at /home/caidenmarley/gameboy/main.cpp:122
122	        while (!bus.ppu.isFrameReady()) {
PPU::isFrameReady (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:46
46	        return frameReady;
47	    }
main (argc=2, argv=0x7fffffffd6e8) at /home/caidenmarley/gameboy/main.cpp:122
122	        while (!bus.ppu.isFrameReady()) {
123	            int m = cpu.step();
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:10
10	    if(imeEnabledNextStep){
16	    if(stopped){
26	    if(halted){
35	    uint8_t ieaValue = bus.read(INTERRUPT_ENABLE_ADDRESS);
Bus::read (this=0x7fffffff3910, address=65535) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::read (this=0x7fffffff3910, address=65535) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
22	    if(address < 0x8000){
25	    }else if(address < 0xA000){
28	    }else if(address < 0xC000){
31	    }else if(address < 0xE000){
34	    }else if(address < 0xFE00){
37	    }else if(address < 0xFEA0){
40	    }else if(address < 0xFF00){
43	    }else if(address == 0xFF00){
63	    }else if(address < 0xFF04){
66	    }else if(address < 0xFF08){
69	    }else if(address >= 0xFF40 && address <= 0xFF4B){
72	    }else if(address < 0xFF80){
75	    }else if(address < 0xFFFF){
80	        return ieReg;
82	}
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:36
36	    uint8_t ifaValue = bus.read(INTERRUPT_FLAG_ADDRESS);
Bus::read (this=0x7fffffff3910, address=65295) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::read (this=0x7fffffff3910, address=65295) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
22	    if(address < 0x8000){
25	    }else if(address < 0xA000){
28	    }else if(address < 0xC000){
31	    }else if(address < 0xE000){
34	    }else if(address < 0xFE00){
37	    }else if(address < 0xFEA0){
40	    }else if(address < 0xFF00){
43	    }else if(address == 0xFF00){
63	    }else if(address < 0xFF04){
66	    }else if(address < 0xFF08){
69	    }else if(address >= 0xFF40 && address <= 0xFF4B){
72	    }else if(address < 0xFF80){
74	        return ioRegs[address - 0xFF00];
82	}
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:37
37	    uint8_t interruptRequest = ieaValue & ifaValue;
38	    if(IME && interruptRequest){
57	    uint8_t opcode = bus.read(PC++);
Bus::read (this=0x7fffffff3910, address=8034) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::read (this=0x7fffffff3910, address=8034) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
22	    if(address < 0x8000){
24	        return cart.readByte(address);
Cartridge::readByte (this=0x7fffffff3860, address=8034) at /home/caidenmarley/gameboy/src/cartridge.cpp:118
118	    if(isMbc2){
135	    if(isMbc1){
159	    if(address < 0x8000){
160	        return romData.at(address);
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=8034) at /usr/include/c++/11/bits/stl_vector.h:1094
1094		_M_range_check(__n);
std::vector<unsigned char, std::allocator<unsigned char> >::_M_range_check (this=0x7fffffff38d0, __n=8034) at /usr/include/c++/11/bits/stl_vector.h:1072
1072		if (__n >= this->size())
std::vector<unsigned char, std::allocator<unsigned char> >::size (this=0x7fffffff38d0) at /usr/include/c++/11/bits/stl_vector.h:919
919	      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
std::vector<unsigned char, std::allocator<unsigned char> >::_M_range_check (this=0x7fffffff38d0, __n=8034) at /usr/include/c++/11/bits/stl_vector.h:1072
1072		if (__n >= this->size())
1077	      }
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=8034) at /usr/include/c++/11/bits/stl_vector.h:1095
1095		return (*this)[__n];
std::vector<unsigned char, std::allocator<unsigned char> >::operator[] (this=0x7fffffff38d0, __n=8034) at /usr/include/c++/11/bits/stl_vector.h:1046
1046		return *(this->_M_impl._M_start + __n);
1047	      }
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=8034) at /usr/include/c++/11/bits/stl_vector.h:1096
1096	      }
Cartridge::readByte (this=0x7fffffff3860, address=8034) at /home/caidenmarley/gameboy/src/cartridge.cpp:160
160	        return romData.at(address);
168	}
Bus::read (this=0x7fffffff3910, address=8034) at /home/caidenmarley/gameboy/src/bus.cpp:24
24	        return cart.readByte(address);
82	}
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:58
58	    return decodeAndExecute(*this, bus, opcode);
decodeAndExecute (cpu=..., bus=..., opcode=224 '\340') at /home/caidenmarley/gameboy/include/instructions.h:93
93	    switch(opcode){
1701	                uint8_t offset = bus.read(cpu.PC++);
Bus::read (this=0x7fffffff3910, address=8035) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::read (this=0x7fffffff3910, address=8035) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
22	    if(address < 0x8000){
24	        return cart.readByte(address);
Cartridge::readByte (this=0x7fffffff3860, address=8035) at /home/caidenmarley/gameboy/src/cartridge.cpp:118
118	    if(isMbc2){
135	    if(isMbc1){
159	    if(address < 0x8000){
160	        return romData.at(address);
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=8035) at /usr/include/c++/11/bits/stl_vector.h:1094
1094		_M_range_check(__n);
std::vector<unsigned char, std::allocator<unsigned char> >::_M_range_check (this=0x7fffffff38d0, __n=8035) at /usr/include/c++/11/bits/stl_vector.h:1072
1072		if (__n >= this->size())
std::vector<unsigned char, std::allocator<unsigned char> >::size (this=0x7fffffff38d0) at /usr/include/c++/11/bits/stl_vector.h:919
919	      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
std::vector<unsigned char, std::allocator<unsigned char> >::_M_range_check (this=0x7fffffff38d0, __n=8035) at /usr/include/c++/11/bits/stl_vector.h:1072
1072		if (__n >= this->size())
1077	      }
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=8035) at /usr/include/c++/11/bits/stl_vector.h:1095
1095		return (*this)[__n];
std::vector<unsigned char, std::allocator<unsigned char> >::operator[] (this=0x7fffffff38d0, __n=8035) at /usr/include/c++/11/bits/stl_vector.h:1046
1046		return *(this->_M_impl._M_start + __n);
1047	      }
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=8035) at /usr/include/c++/11/bits/stl_vector.h:1096
1096	      }
Cartridge::readByte (this=0x7fffffff3860, address=8035) at /home/caidenmarley/gameboy/src/cartridge.cpp:160
160	        return romData.at(address);
168	}
Bus::read (this=0x7fffffff3910, address=8035) at /home/caidenmarley/gameboy/src/bus.cpp:24
24	        return cart.readByte(address);
82	}
decodeAndExecute (cpu=..., bus=..., opcode=224 '\340') at /home/caidenmarley/gameboy/include/instructions.h:1702
1702	                if ((0xFF00u + offset) == 0xFF40 || (0xFF00u + offset) == 0xFF41) {
1711	                bus.write(0xFF00 + offset, cpu.A);
Bus::write (this=0x7fffffff3910, address=65355, byte=0 '\000') at /home/caidenmarley/gameboy/src/bus.cpp:85
85	    if(address == 0xFF00){
89	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::write (this=0x7fffffff3910, address=65355, byte=0 '\000') at /home/caidenmarley/gameboy/src/bus.cpp:89
89	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
94	    if(address < 0x8000){
97	    }else if(address < 0xA000){
100	    }else if(address < 0xC000){
103	    }else if(address < 0xE000){
106	    }else if(address < 0xFE00){
109	    }else if(address < 0xFEA0){
112	    }else if(address < 0xFF00){
114	    }else if(address < 0xFF04){
117	    }else if(address < 0xFF08){
120	    }else if(address >= 0xFF40 && address <= 0xFF4B){
122	        std::cout << "here2" << std::endl;
123	        if(address == 0xFF40){
126	        ppu.write(address, byte);
PPU::write (this=0x7fffffff3910, address=65355, byte=0 '\000') at /home/caidenmarley/gameboy/src/ppu.cpp:182
182	    if(address == 0xFF46){
194	    if(address >= 0x8000 && address <= 0x9FFF){
203	    if(address >= 0xFE00 && address <= 0xFE9F){
210	    if(address == 0xFF40){
214	    switch(address){
240	        case WX_ADDRESS: WX = byte; break;
243	}
Bus::write (this=0x7fffffff3910, address=65355, byte=0 '\000') at /home/caidenmarley/gameboy/src/bus.cpp:137
137	}
decodeAndExecute (cpu=..., bus=..., opcode=224 '\340') at /home/caidenmarley/gameboy/include/instructions.h:1712
1712	                return 3;
1886	}
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:58
58	    return decodeAndExecute(*this, bus, opcode);
59	}
main (argc=2, argv=0x7fffffffd6e8) at /home/caidenmarley/gameboy/main.cpp:124
124	            bus.step(m * 4, cpu);
Bus::step (this=0x7fffffff3910, tStates=12, cpu=...) at /home/caidenmarley/gameboy/src/bus.cpp:140
140	    timer.step(tStates, cpu);
Timer::step (this=0x7fffffffb4a0, tStates=12, cpu=...) at /home/caidenmarley/gameboy/src/timer.cpp:8
8	    divCounter += tStates;
9	    while(divCounter >= 256){
15	    if(TAC & 0x04){
30	}
Bus::step (this=0x7fffffff3910, tStates=12, cpu=...) at /home/caidenmarley/gameboy/src/bus.cpp:141
141	    ppu.step(tStates, cpu);
PPU::step (this=0x7fffffff3910, tStates=12, cpu=...) at /home/caidenmarley/gameboy/src/ppu.cpp:17
17	void PPU::step(int tStates, CPU& cpu){
18	    stepDma(tStates);
PPU::stepDma (this=0x7fffffff3910, cycles=12) at /home/caidenmarley/gameboy/include/ppu.h:151
151	        if(!oamDmaActive) return;
156	    }
PPU::step (this=0x7fffffff3910, tStates=12, cpu=...) at /home/caidenmarley/gameboy/src/ppu.cpp:20
20	    if(!(LCDC & 0x80)){
24	    dotCounter += tStates;
27	        uint8_t mode = STAT & 0x03;
28	        int needed = 0;
30	        switch(mode){
46	            case 1: needed = 4560; break;
50	        if (dotCounter < needed){
51	            break;
142	}
Bus::step (this=0x7fffffff3910, tStates=12, cpu=...) at /home/caidenmarley/gameboy/src/bus.cpp:143
143	}
main (argc=2, argv=0x7fffffffd6e8) at /home/caidenmarley/gameboy/main.cpp:122
122	        while (!bus.ppu.isFrameReady()) {
PPU::isFrameReady (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:46
46	        return frameReady;
47	    }
main (argc=2, argv=0x7fffffffd6e8) at /home/caidenmarley/gameboy/main.cpp:122
122	        while (!bus.ppu.isFrameReady()) {
123	            int m = cpu.step();
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:10
10	    if(imeEnabledNextStep){
16	    if(stopped){
26	    if(halted){
35	    uint8_t ieaValue = bus.read(INTERRUPT_ENABLE_ADDRESS);
Bus::read (this=0x7fffffff3910, address=65535) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::read (this=0x7fffffff3910, address=65535) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
22	    if(address < 0x8000){
25	    }else if(address < 0xA000){
28	    }else if(address < 0xC000){
31	    }else if(address < 0xE000){
34	    }else if(address < 0xFE00){
37	    }else if(address < 0xFEA0){
40	    }else if(address < 0xFF00){
43	    }else if(address == 0xFF00){
63	    }else if(address < 0xFF04){
66	    }else if(address < 0xFF08){
69	    }else if(address >= 0xFF40 && address <= 0xFF4B){
72	    }else if(address < 0xFF80){
75	    }else if(address < 0xFFFF){
80	        return ieReg;
82	}
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:36
36	    uint8_t ifaValue = bus.read(INTERRUPT_FLAG_ADDRESS);
Bus::read (this=0x7fffffff3910, address=65295) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::read (this=0x7fffffff3910, address=65295) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
22	    if(address < 0x8000){
25	    }else if(address < 0xA000){
28	    }else if(address < 0xC000){
31	    }else if(address < 0xE000){
34	    }else if(address < 0xFE00){
37	    }else if(address < 0xFEA0){
40	    }else if(address < 0xFF00){
43	    }else if(address == 0xFF00){
63	    }else if(address < 0xFF04){
66	    }else if(address < 0xFF08){
69	    }else if(address >= 0xFF40 && address <= 0xFF4B){
72	    }else if(address < 0xFF80){
74	        return ioRegs[address - 0xFF00];
82	}
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:37
37	    uint8_t interruptRequest = ieaValue & ifaValue;
38	    if(IME && interruptRequest){
57	    uint8_t opcode = bus.read(PC++);
Bus::read (this=0x7fffffff3910, address=8036) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::read (this=0x7fffffff3910, address=8036) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
22	    if(address < 0x8000){
24	        return cart.readByte(address);
Cartridge::readByte (this=0x7fffffff3860, address=8036) at /home/caidenmarley/gameboy/src/cartridge.cpp:118
118	    if(isMbc2){
135	    if(isMbc1){
159	    if(address < 0x8000){
160	        return romData.at(address);
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=8036) at /usr/include/c++/11/bits/stl_vector.h:1094
1094		_M_range_check(__n);
std::vector<unsigned char, std::allocator<unsigned char> >::_M_range_check (this=0x7fffffff38d0, __n=8036) at /usr/include/c++/11/bits/stl_vector.h:1072
1072		if (__n >= this->size())
std::vector<unsigned char, std::allocator<unsigned char> >::size (this=0x7fffffff38d0) at /usr/include/c++/11/bits/stl_vector.h:919
919	      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
std::vector<unsigned char, std::allocator<unsigned char> >::_M_range_check (this=0x7fffffff38d0, __n=8036) at /usr/include/c++/11/bits/stl_vector.h:1072
1072		if (__n >= this->size())
1077	      }
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=8036) at /usr/include/c++/11/bits/stl_vector.h:1095
1095		return (*this)[__n];
std::vector<unsigned char, std::allocator<unsigned char> >::operator[] (this=0x7fffffff38d0, __n=8036) at /usr/include/c++/11/bits/stl_vector.h:1046
1046		return *(this->_M_impl._M_start + __n);
1047	      }
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=8036) at /usr/include/c++/11/bits/stl_vector.h:1096
1096	      }
Cartridge::readByte (this=0x7fffffff3860, address=8036) at /home/caidenmarley/gameboy/src/cartridge.cpp:160
160	        return romData.at(address);
168	}
Bus::read (this=0x7fffffff3910, address=8036) at /home/caidenmarley/gameboy/src/bus.cpp:24
24	        return cart.readByte(address);
82	}
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:58
58	    return decodeAndExecute(*this, bus, opcode);
decodeAndExecute (cpu=..., bus=..., opcode=224 '\340') at /home/caidenmarley/gameboy/include/instructions.h:93
93	    switch(opcode){
1701	                uint8_t offset = bus.read(cpu.PC++);
Bus::read (this=0x7fffffff3910, address=8037) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::read (this=0x7fffffff3910, address=8037) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
22	    if(address < 0x8000){
24	        return cart.readByte(address);
Cartridge::readByte (this=0x7fffffff3860, address=8037) at /home/caidenmarley/gameboy/src/cartridge.cpp:118
118	    if(isMbc2){
135	    if(isMbc1){
159	    if(address < 0x8000){
160	        return romData.at(address);
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=8037) at /usr/include/c++/11/bits/stl_vector.h:1094
1094		_M_range_check(__n);
std::vector<unsigned char, std::allocator<unsigned char> >::_M_range_check (this=0x7fffffff38d0, __n=8037) at /usr/include/c++/11/bits/stl_vector.h:1072
1072		if (__n >= this->size())
std::vector<unsigned char, std::allocator<unsigned char> >::size (this=0x7fffffff38d0) at /usr/include/c++/11/bits/stl_vector.h:919
919	      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
std::vector<unsigned char, std::allocator<unsigned char> >::_M_range_check (this=0x7fffffff38d0, __n=8037) at /usr/include/c++/11/bits/stl_vector.h:1072
1072		if (__n >= this->size())
1077	      }
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=8037) at /usr/include/c++/11/bits/stl_vector.h:1095
1095		return (*this)[__n];
std::vector<unsigned char, std::allocator<unsigned char> >::operator[] (this=0x7fffffff38d0, __n=8037) at /usr/include/c++/11/bits/stl_vector.h:1046
1046		return *(this->_M_impl._M_start + __n);
1047	      }
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=8037) at /usr/include/c++/11/bits/stl_vector.h:1096
1096	      }
Cartridge::readByte (this=0x7fffffff3860, address=8037) at /home/caidenmarley/gameboy/src/cartridge.cpp:160
160	        return romData.at(address);
168	}
Bus::read (this=0x7fffffff3910, address=8037) at /home/caidenmarley/gameboy/src/bus.cpp:24
24	        return cart.readByte(address);
82	}
decodeAndExecute (cpu=..., bus=..., opcode=224 '\340') at /home/caidenmarley/gameboy/include/instructions.h:1702
1702	                if ((0xFF00u + offset) == 0xFF40 || (0xFF00u + offset) == 0xFF41) {
1711	                bus.write(0xFF00 + offset, cpu.A);
Bus::write (this=0x7fffffff3910, address=65354, byte=0 '\000') at /home/caidenmarley/gameboy/src/bus.cpp:85
85	    if(address == 0xFF00){
89	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::write (this=0x7fffffff3910, address=65354, byte=0 '\000') at /home/caidenmarley/gameboy/src/bus.cpp:89
89	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
94	    if(address < 0x8000){
97	    }else if(address < 0xA000){
100	    }else if(address < 0xC000){
103	    }else if(address < 0xE000){
106	    }else if(address < 0xFE00){
109	    }else if(address < 0xFEA0){
112	    }else if(address < 0xFF00){
114	    }else if(address < 0xFF04){
117	    }else if(address < 0xFF08){
120	    }else if(address >= 0xFF40 && address <= 0xFF4B){
122	        std::cout << "here2" << std::endl;
123	        if(address == 0xFF40){
126	        ppu.write(address, byte);
PPU::write (this=0x7fffffff3910, address=65354, byte=0 '\000') at /home/caidenmarley/gameboy/src/ppu.cpp:182
182	    if(address == 0xFF46){
194	    if(address >= 0x8000 && address <= 0x9FFF){
203	    if(address >= 0xFE00 && address <= 0xFE9F){
210	    if(address == 0xFF40){
214	    switch(address){
239	        case WY_ADDRESS: WY = byte; break;
243	}
Bus::write (this=0x7fffffff3910, address=65354, byte=0 '\000') at /home/caidenmarley/gameboy/src/bus.cpp:137
137	}
decodeAndExecute (cpu=..., bus=..., opcode=224 '\340') at /home/caidenmarley/gameboy/include/instructions.h:1712
1712	                return 3;
1886	}
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:58
58	    return decodeAndExecute(*this, bus, opcode);
59	}
main (argc=2, argv=0x7fffffffd6e8) at /home/caidenmarley/gameboy/main.cpp:124
124	            bus.step(m * 4, cpu);
Bus::step (this=0x7fffffff3910, tStates=12, cpu=...) at /home/caidenmarley/gameboy/src/bus.cpp:140
140	    timer.step(tStates, cpu);
Timer::step (this=0x7fffffffb4a0, tStates=12, cpu=...) at /home/caidenmarley/gameboy/src/timer.cpp:8
8	    divCounter += tStates;
9	    while(divCounter >= 256){
15	    if(TAC & 0x04){
30	}
Bus::step (this=0x7fffffff3910, tStates=12, cpu=...) at /home/caidenmarley/gameboy/src/bus.cpp:141
141	    ppu.step(tStates, cpu);
PPU::step (this=0x7fffffff3910, tStates=12, cpu=...) at /home/caidenmarley/gameboy/src/ppu.cpp:17
17	void PPU::step(int tStates, CPU& cpu){
18	    stepDma(tStates);
PPU::stepDma (this=0x7fffffff3910, cycles=12) at /home/caidenmarley/gameboy/include/ppu.h:151
151	        if(!oamDmaActive) return;
156	    }
PPU::step (this=0x7fffffff3910, tStates=12, cpu=...) at /home/caidenmarley/gameboy/src/ppu.cpp:20
20	    if(!(LCDC & 0x80)){
24	    dotCounter += tStates;
27	        uint8_t mode = STAT & 0x03;
28	        int needed = 0;
30	        switch(mode){
46	            case 1: needed = 4560; break;
50	        if (dotCounter < needed){
51	            break;
142	}
Bus::step (this=0x7fffffff3910, tStates=12, cpu=...) at /home/caidenmarley/gameboy/src/bus.cpp:143
143	}
main (argc=2, argv=0x7fffffffd6e8) at /home/caidenmarley/gameboy/main.cpp:122
122	        while (!bus.ppu.isFrameReady()) {
PPU::isFrameReady (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:46
46	        return frameReady;
47	    }
main (argc=2, argv=0x7fffffffd6e8) at /home/caidenmarley/gameboy/main.cpp:122
122	        while (!bus.ppu.isFrameReady()) {
123	            int m = cpu.step();
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:10
10	    if(imeEnabledNextStep){
16	    if(stopped){
26	    if(halted){
35	    uint8_t ieaValue = bus.read(INTERRUPT_ENABLE_ADDRESS);
Bus::read (this=0x7fffffff3910, address=65535) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::read (this=0x7fffffff3910, address=65535) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
22	    if(address < 0x8000){
25	    }else if(address < 0xA000){
28	    }else if(address < 0xC000){
31	    }else if(address < 0xE000){
34	    }else if(address < 0xFE00){
37	    }else if(address < 0xFEA0){
40	    }else if(address < 0xFF00){
43	    }else if(address == 0xFF00){
63	    }else if(address < 0xFF04){
66	    }else if(address < 0xFF08){
69	    }else if(address >= 0xFF40 && address <= 0xFF4B){
72	    }else if(address < 0xFF80){
75	    }else if(address < 0xFFFF){
80	        return ieReg;
82	}
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:36
36	    uint8_t ifaValue = bus.read(INTERRUPT_FLAG_ADDRESS);
Bus::read (this=0x7fffffff3910, address=65295) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::read (this=0x7fffffff3910, address=65295) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
22	    if(address < 0x8000){
25	    }else if(address < 0xA000){
28	    }else if(address < 0xC000){
31	    }else if(address < 0xE000){
34	    }else if(address < 0xFE00){
37	    }else if(address < 0xFEA0){
40	    }else if(address < 0xFF00){
43	    }else if(address == 0xFF00){
63	    }else if(address < 0xFF04){
66	    }else if(address < 0xFF08){
69	    }else if(address >= 0xFF40 && address <= 0xFF4B){
72	    }else if(address < 0xFF80){
74	        return ioRegs[address - 0xFF00];
82	}
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:37
37	    uint8_t interruptRequest = ieaValue & ifaValue;
38	    if(IME && interruptRequest){
57	    uint8_t opcode = bus.read(PC++);
Bus::read (this=0x7fffffff3910, address=8038) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::read (this=0x7fffffff3910, address=8038) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
22	    if(address < 0x8000){
24	        return cart.readByte(address);
Cartridge::readByte (this=0x7fffffff3860, address=8038) at /home/caidenmarley/gameboy/src/cartridge.cpp:118
118	    if(isMbc2){
135	    if(isMbc1){
159	    if(address < 0x8000){
160	        return romData.at(address);
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=8038) at /usr/include/c++/11/bits/stl_vector.h:1094
1094		_M_range_check(__n);
std::vector<unsigned char, std::allocator<unsigned char> >::_M_range_check (this=0x7fffffff38d0, __n=8038) at /usr/include/c++/11/bits/stl_vector.h:1072
1072		if (__n >= this->size())
std::vector<unsigned char, std::allocator<unsigned char> >::size (this=0x7fffffff38d0) at /usr/include/c++/11/bits/stl_vector.h:919
919	      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
std::vector<unsigned char, std::allocator<unsigned char> >::_M_range_check (this=0x7fffffff38d0, __n=8038) at /usr/include/c++/11/bits/stl_vector.h:1072
1072		if (__n >= this->size())
1077	      }
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=8038) at /usr/include/c++/11/bits/stl_vector.h:1095
1095		return (*this)[__n];
std::vector<unsigned char, std::allocator<unsigned char> >::operator[] (this=0x7fffffff38d0, __n=8038) at /usr/include/c++/11/bits/stl_vector.h:1046
1046		return *(this->_M_impl._M_start + __n);
1047	      }
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=8038) at /usr/include/c++/11/bits/stl_vector.h:1096
1096	      }
Cartridge::readByte (this=0x7fffffff3860, address=8038) at /home/caidenmarley/gameboy/src/cartridge.cpp:160
160	        return romData.at(address);
168	}
Bus::read (this=0x7fffffff3910, address=8038) at /home/caidenmarley/gameboy/src/bus.cpp:24
24	        return cart.readByte(address);
82	}
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:58
58	    return decodeAndExecute(*this, bus, opcode);
decodeAndExecute (cpu=..., bus=..., opcode=224 '\340') at /home/caidenmarley/gameboy/include/instructions.h:93
93	    switch(opcode){
1701	                uint8_t offset = bus.read(cpu.PC++);
Bus::read (this=0x7fffffff3910, address=8039) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::read (this=0x7fffffff3910, address=8039) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
22	    if(address < 0x8000){
24	        return cart.readByte(address);
Cartridge::readByte (this=0x7fffffff3860, address=8039) at /home/caidenmarley/gameboy/src/cartridge.cpp:118
118	    if(isMbc2){
135	    if(isMbc1){
159	    if(address < 0x8000){
160	        return romData.at(address);
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=8039) at /usr/include/c++/11/bits/stl_vector.h:1094
1094		_M_range_check(__n);
std::vector<unsigned char, std::allocator<unsigned char> >::_M_range_check (this=0x7fffffff38d0, __n=8039) at /usr/include/c++/11/bits/stl_vector.h:1072
1072		if (__n >= this->size())
std::vector<unsigned char, std::allocator<unsigned char> >::size (this=0x7fffffff38d0) at /usr/include/c++/11/bits/stl_vector.h:919
919	      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
std::vector<unsigned char, std::allocator<unsigned char> >::_M_range_check (this=0x7fffffff38d0, __n=8039) at /usr/include/c++/11/bits/stl_vector.h:1072
1072		if (__n >= this->size())
1077	      }
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=8039) at /usr/include/c++/11/bits/stl_vector.h:1095
1095		return (*this)[__n];
std::vector<unsigned char, std::allocator<unsigned char> >::operator[] (this=0x7fffffff38d0, __n=8039) at /usr/include/c++/11/bits/stl_vector.h:1046
1046		return *(this->_M_impl._M_start + __n);
1047	      }
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=8039) at /usr/include/c++/11/bits/stl_vector.h:1096
1096	      }
Cartridge::readByte (this=0x7fffffff3860, address=8039) at /home/caidenmarley/gameboy/src/cartridge.cpp:160
160	        return romData.at(address);
168	}
Bus::read (this=0x7fffffff3910, address=8039) at /home/caidenmarley/gameboy/src/bus.cpp:24
24	        return cart.readByte(address);
82	}
decodeAndExecute (cpu=..., bus=..., opcode=224 '\340') at /home/caidenmarley/gameboy/include/instructions.h:1702
1702	                if ((0xFF00u + offset) == 0xFF40 || (0xFF00u + offset) == 0xFF41) {
1711	                bus.write(0xFF00 + offset, cpu.A);
Bus::write (this=0x7fffffff3910, address=65286, byte=0 '\000') at /home/caidenmarley/gameboy/src/bus.cpp:85
85	    if(address == 0xFF00){
89	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::write (this=0x7fffffff3910, address=65286, byte=0 '\000') at /home/caidenmarley/gameboy/src/bus.cpp:89
89	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
94	    if(address < 0x8000){
97	    }else if(address < 0xA000){
100	    }else if(address < 0xC000){
103	    }else if(address < 0xE000){
106	    }else if(address < 0xFE00){
109	    }else if(address < 0xFEA0){
112	    }else if(address < 0xFF00){
114	    }else if(address < 0xFF04){
117	    }else if(address < 0xFF08){
119	        timer.write(address, byte);
Timer::write (this=0x7fffffffb4a0, address=65286, byte=0 '\000') at /home/caidenmarley/gameboy/src/timer.cpp:43
43	    switch(address){
46	        case TMA_ADDRESS: TMA = byte; break; // FF06
50	}
Bus::write (this=0x7fffffff3910, address=65286, byte=0 '\000') at /home/caidenmarley/gameboy/src/bus.cpp:137
137	}
decodeAndExecute (cpu=..., bus=..., opcode=224 '\340') at /home/caidenmarley/gameboy/include/instructions.h:1712
1712	                return 3;
1886	}
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:58
58	    return decodeAndExecute(*this, bus, opcode);
59	}
main (argc=2, argv=0x7fffffffd6e8) at /home/caidenmarley/gameboy/main.cpp:124
124	            bus.step(m * 4, cpu);
Bus::step (this=0x7fffffff3910, tStates=12, cpu=...) at /home/caidenmarley/gameboy/src/bus.cpp:140
140	    timer.step(tStates, cpu);
Timer::step (this=0x7fffffffb4a0, tStates=12, cpu=...) at /home/caidenmarley/gameboy/src/timer.cpp:8
8	    divCounter += tStates;
9	    while(divCounter >= 256){
15	    if(TAC & 0x04){
30	}
Bus::step (this=0x7fffffff3910, tStates=12, cpu=...) at /home/caidenmarley/gameboy/src/bus.cpp:141
141	    ppu.step(tStates, cpu);
PPU::step (this=0x7fffffff3910, tStates=12, cpu=...) at /home/caidenmarley/gameboy/src/ppu.cpp:17
17	void PPU::step(int tStates, CPU& cpu){
18	    stepDma(tStates);
PPU::stepDma (this=0x7fffffff3910, cycles=12) at /home/caidenmarley/gameboy/include/ppu.h:151
151	        if(!oamDmaActive) return;
156	    }
PPU::step (this=0x7fffffff3910, tStates=12, cpu=...) at /home/caidenmarley/gameboy/src/ppu.cpp:20
20	    if(!(LCDC & 0x80)){
24	    dotCounter += tStates;
27	        uint8_t mode = STAT & 0x03;
28	        int needed = 0;
30	        switch(mode){
46	            case 1: needed = 4560; break;
50	        if (dotCounter < needed){
51	            break;
142	}
Bus::step (this=0x7fffffff3910, tStates=12, cpu=...) at /home/caidenmarley/gameboy/src/bus.cpp:143
143	}
main (argc=2, argv=0x7fffffffd6e8) at /home/caidenmarley/gameboy/main.cpp:122
122	        while (!bus.ppu.isFrameReady()) {
PPU::isFrameReady (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:46
46	        return frameReady;
47	    }
main (argc=2, argv=0x7fffffffd6e8) at /home/caidenmarley/gameboy/main.cpp:122
122	        while (!bus.ppu.isFrameReady()) {
123	            int m = cpu.step();
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:10
10	    if(imeEnabledNextStep){
16	    if(stopped){
26	    if(halted){
35	    uint8_t ieaValue = bus.read(INTERRUPT_ENABLE_ADDRESS);
Bus::read (this=0x7fffffff3910, address=65535) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::read (this=0x7fffffff3910, address=65535) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
22	    if(address < 0x8000){
25	    }else if(address < 0xA000){
28	    }else if(address < 0xC000){
31	    }else if(address < 0xE000){
34	    }else if(address < 0xFE00){
37	    }else if(address < 0xFEA0){
40	    }else if(address < 0xFF00){
43	    }else if(address == 0xFF00){
63	    }else if(address < 0xFF04){
66	    }else if(address < 0xFF08){
69	    }else if(address >= 0xFF40 && address <= 0xFF4B){
72	    }else if(address < 0xFF80){
75	    }else if(address < 0xFFFF){
80	        return ieReg;
82	}
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:36
36	    uint8_t ifaValue = bus.read(INTERRUPT_FLAG_ADDRESS);
Bus::read (this=0x7fffffff3910, address=65295) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::read (this=0x7fffffff3910, address=65295) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
22	    if(address < 0x8000){
25	    }else if(address < 0xA000){
28	    }else if(address < 0xC000){
31	    }else if(address < 0xE000){
34	    }else if(address < 0xFE00){
37	    }else if(address < 0xFEA0){
40	    }else if(address < 0xFF00){
43	    }else if(address == 0xFF00){
63	    }else if(address < 0xFF04){
66	    }else if(address < 0xFF08){
69	    }else if(address >= 0xFF40 && address <= 0xFF4B){
72	    }else if(address < 0xFF80){
74	        return ioRegs[address - 0xFF00];
82	}
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:37
37	    uint8_t interruptRequest = ieaValue & ifaValue;
38	    if(IME && interruptRequest){
57	    uint8_t opcode = bus.read(PC++);
Bus::read (this=0x7fffffff3910, address=8040) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::read (this=0x7fffffff3910, address=8040) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
22	    if(address < 0x8000){
24	        return cart.readByte(address);
Cartridge::readByte (this=0x7fffffff3860, address=8040) at /home/caidenmarley/gameboy/src/cartridge.cpp:118
118	    if(isMbc2){
135	    if(isMbc1){
159	    if(address < 0x8000){
160	        return romData.at(address);
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=8040) at /usr/include/c++/11/bits/stl_vector.h:1094
1094		_M_range_check(__n);
std::vector<unsigned char, std::allocator<unsigned char> >::_M_range_check (this=0x7fffffff38d0, __n=8040) at /usr/include/c++/11/bits/stl_vector.h:1072
1072		if (__n >= this->size())
std::vector<unsigned char, std::allocator<unsigned char> >::size (this=0x7fffffff38d0) at /usr/include/c++/11/bits/stl_vector.h:919
919	      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
std::vector<unsigned char, std::allocator<unsigned char> >::_M_range_check (this=0x7fffffff38d0, __n=8040) at /usr/include/c++/11/bits/stl_vector.h:1072
1072		if (__n >= this->size())
1077	      }
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=8040) at /usr/include/c++/11/bits/stl_vector.h:1095
1095		return (*this)[__n];
std::vector<unsigned char, std::allocator<unsigned char> >::operator[] (this=0x7fffffff38d0, __n=8040) at /usr/include/c++/11/bits/stl_vector.h:1046
1046		return *(this->_M_impl._M_start + __n);
1047	      }
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=8040) at /usr/include/c++/11/bits/stl_vector.h:1096
1096	      }
Cartridge::readByte (this=0x7fffffff3860, address=8040) at /home/caidenmarley/gameboy/src/cartridge.cpp:160
160	        return romData.at(address);
168	}
Bus::read (this=0x7fffffff3910, address=8040) at /home/caidenmarley/gameboy/src/bus.cpp:24
24	        return cart.readByte(address);
82	}
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:58
58	    return decodeAndExecute(*this, bus, opcode);
decodeAndExecute (cpu=..., bus=..., opcode=224 '\340') at /home/caidenmarley/gameboy/include/instructions.h:93
93	    switch(opcode){
1701	                uint8_t offset = bus.read(cpu.PC++);
Bus::read (this=0x7fffffff3910, address=8041) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::read (this=0x7fffffff3910, address=8041) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
22	    if(address < 0x8000){
24	        return cart.readByte(address);
Cartridge::readByte (this=0x7fffffff3860, address=8041) at /home/caidenmarley/gameboy/src/cartridge.cpp:118
118	    if(isMbc2){
135	    if(isMbc1){
159	    if(address < 0x8000){
160	        return romData.at(address);
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=8041) at /usr/include/c++/11/bits/stl_vector.h:1094
1094		_M_range_check(__n);
std::vector<unsigned char, std::allocator<unsigned char> >::_M_range_check (this=0x7fffffff38d0, __n=8041) at /usr/include/c++/11/bits/stl_vector.h:1072
1072		if (__n >= this->size())
std::vector<unsigned char, std::allocator<unsigned char> >::size (this=0x7fffffff38d0) at /usr/include/c++/11/bits/stl_vector.h:919
919	      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
std::vector<unsigned char, std::allocator<unsigned char> >::_M_range_check (this=0x7fffffff38d0, __n=8041) at /usr/include/c++/11/bits/stl_vector.h:1072
1072		if (__n >= this->size())
1077	      }
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=8041) at /usr/include/c++/11/bits/stl_vector.h:1095
1095		return (*this)[__n];
std::vector<unsigned char, std::allocator<unsigned char> >::operator[] (this=0x7fffffff38d0, __n=8041) at /usr/include/c++/11/bits/stl_vector.h:1046
1046		return *(this->_M_impl._M_start + __n);
1047	      }
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=8041) at /usr/include/c++/11/bits/stl_vector.h:1096
1096	      }
Cartridge::readByte (this=0x7fffffff3860, address=8041) at /home/caidenmarley/gameboy/src/cartridge.cpp:160
160	        return romData.at(address);
168	}
Bus::read (this=0x7fffffff3910, address=8041) at /home/caidenmarley/gameboy/src/bus.cpp:24
24	        return cart.readByte(address);
82	}
decodeAndExecute (cpu=..., bus=..., opcode=224 '\340') at /home/caidenmarley/gameboy/include/instructions.h:1702
1702	                if ((0xFF00u + offset) == 0xFF40 || (0xFF00u + offset) == 0xFF41) {
1711	                bus.write(0xFF00 + offset, cpu.A);
Bus::write (this=0x7fffffff3910, address=65287, byte=0 '\000') at /home/caidenmarley/gameboy/src/bus.cpp:85
85	    if(address == 0xFF00){
89	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::write (this=0x7fffffff3910, address=65287, byte=0 '\000') at /home/caidenmarley/gameboy/src/bus.cpp:89
89	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
94	    if(address < 0x8000){
97	    }else if(address < 0xA000){
100	    }else if(address < 0xC000){
103	    }else if(address < 0xE000){
106	    }else if(address < 0xFE00){
109	    }else if(address < 0xFEA0){
112	    }else if(address < 0xFF00){
114	    }else if(address < 0xFF04){
117	    }else if(address < 0xFF08){
119	        timer.write(address, byte);
Timer::write (this=0x7fffffffb4a0, address=65287, byte=0 '\000') at /home/caidenmarley/gameboy/src/timer.cpp:43
43	    switch(address){
47	        case TAC_ADDRESS: TAC = byte & 0x07; break; // FF07, only bits 2-0 are used
50	}
Bus::write (this=0x7fffffff3910, address=65287, byte=0 '\000') at /home/caidenmarley/gameboy/src/bus.cpp:137
137	}
decodeAndExecute (cpu=..., bus=..., opcode=224 '\340') at /home/caidenmarley/gameboy/include/instructions.h:1712
1712	                return 3;
1886	}
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:58
58	    return decodeAndExecute(*this, bus, opcode);
59	}
main (argc=2, argv=0x7fffffffd6e8) at /home/caidenmarley/gameboy/main.cpp:124
124	            bus.step(m * 4, cpu);
Bus::step (this=0x7fffffff3910, tStates=12, cpu=...) at /home/caidenmarley/gameboy/src/bus.cpp:140
140	    timer.step(tStates, cpu);
Timer::step (this=0x7fffffffb4a0, tStates=12, cpu=...) at /home/caidenmarley/gameboy/src/timer.cpp:8
8	    divCounter += tStates;
9	    while(divCounter >= 256){
15	    if(TAC & 0x04){
30	}
Bus::step (this=0x7fffffff3910, tStates=12, cpu=...) at /home/caidenmarley/gameboy/src/bus.cpp:141
141	    ppu.step(tStates, cpu);
PPU::step (this=0x7fffffff3910, tStates=12, cpu=...) at /home/caidenmarley/gameboy/src/ppu.cpp:17
17	void PPU::step(int tStates, CPU& cpu){
18	    stepDma(tStates);
PPU::stepDma (this=0x7fffffff3910, cycles=12) at /home/caidenmarley/gameboy/include/ppu.h:151
151	        if(!oamDmaActive) return;
156	    }
PPU::step (this=0x7fffffff3910, tStates=12, cpu=...) at /home/caidenmarley/gameboy/src/ppu.cpp:20
20	    if(!(LCDC & 0x80)){
24	    dotCounter += tStates;
27	        uint8_t mode = STAT & 0x03;
28	        int needed = 0;
30	        switch(mode){
46	            case 1: needed = 4560; break;
50	        if (dotCounter < needed){
51	            break;
142	}
Bus::step (this=0x7fffffff3910, tStates=12, cpu=...) at /home/caidenmarley/gameboy/src/bus.cpp:143
143	}
main (argc=2, argv=0x7fffffffd6e8) at /home/caidenmarley/gameboy/main.cpp:122
122	        while (!bus.ppu.isFrameReady()) {
PPU::isFrameReady (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:46
46	        return frameReady;
47	    }
main (argc=2, argv=0x7fffffffd6e8) at /home/caidenmarley/gameboy/main.cpp:122
122	        while (!bus.ppu.isFrameReady()) {
123	            int m = cpu.step();
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:10
10	    if(imeEnabledNextStep){
16	    if(stopped){
26	    if(halted){
35	    uint8_t ieaValue = bus.read(INTERRUPT_ENABLE_ADDRESS);
Bus::read (this=0x7fffffff3910, address=65535) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::read (this=0x7fffffff3910, address=65535) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
22	    if(address < 0x8000){
25	    }else if(address < 0xA000){
28	    }else if(address < 0xC000){
31	    }else if(address < 0xE000){
34	    }else if(address < 0xFE00){
37	    }else if(address < 0xFEA0){
40	    }else if(address < 0xFF00){
43	    }else if(address == 0xFF00){
63	    }else if(address < 0xFF04){
66	    }else if(address < 0xFF08){
69	    }else if(address >= 0xFF40 && address <= 0xFF4B){
72	    }else if(address < 0xFF80){
75	    }else if(address < 0xFFFF){
80	        return ieReg;
82	}
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:36
36	    uint8_t ifaValue = bus.read(INTERRUPT_FLAG_ADDRESS);
Bus::read (this=0x7fffffff3910, address=65295) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::read (this=0x7fffffff3910, address=65295) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
22	    if(address < 0x8000){
25	    }else if(address < 0xA000){
28	    }else if(address < 0xC000){
31	    }else if(address < 0xE000){
34	    }else if(address < 0xFE00){
37	    }else if(address < 0xFEA0){
40	    }else if(address < 0xFF00){
43	    }else if(address == 0xFF00){
63	    }else if(address < 0xFF04){
66	    }else if(address < 0xFF08){
69	    }else if(address >= 0xFF40 && address <= 0xFF4B){
72	    }else if(address < 0xFF80){
74	        return ioRegs[address - 0xFF00];
82	}
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:37
37	    uint8_t interruptRequest = ieaValue & ifaValue;
38	    if(IME && interruptRequest){
57	    uint8_t opcode = bus.read(PC++);
Bus::read (this=0x7fffffff3910, address=8042) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::read (this=0x7fffffff3910, address=8042) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
22	    if(address < 0x8000){
24	        return cart.readByte(address);
Cartridge::readByte (this=0x7fffffff3860, address=8042) at /home/caidenmarley/gameboy/src/cartridge.cpp:118
118	    if(isMbc2){
135	    if(isMbc1){
159	    if(address < 0x8000){
160	        return romData.at(address);
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=8042) at /usr/include/c++/11/bits/stl_vector.h:1094
1094		_M_range_check(__n);
std::vector<unsigned char, std::allocator<unsigned char> >::_M_range_check (this=0x7fffffff38d0, __n=8042) at /usr/include/c++/11/bits/stl_vector.h:1072
1072		if (__n >= this->size())
std::vector<unsigned char, std::allocator<unsigned char> >::size (this=0x7fffffff38d0) at /usr/include/c++/11/bits/stl_vector.h:919
919	      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
std::vector<unsigned char, std::allocator<unsigned char> >::_M_range_check (this=0x7fffffff38d0, __n=8042) at /usr/include/c++/11/bits/stl_vector.h:1072
1072		if (__n >= this->size())
1077	      }
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=8042) at /usr/include/c++/11/bits/stl_vector.h:1095
1095		return (*this)[__n];
std::vector<unsigned char, std::allocator<unsigned char> >::operator[] (this=0x7fffffff38d0, __n=8042) at /usr/include/c++/11/bits/stl_vector.h:1046
1046		return *(this->_M_impl._M_start + __n);
1047	      }
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=8042) at /usr/include/c++/11/bits/stl_vector.h:1096
1096	      }
Cartridge::readByte (this=0x7fffffff3860, address=8042) at /home/caidenmarley/gameboy/src/cartridge.cpp:160
160	        return romData.at(address);
168	}
Bus::read (this=0x7fffffff3910, address=8042) at /home/caidenmarley/gameboy/src/bus.cpp:24
24	        return cart.readByte(address);
82	}
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:58
58	    return decodeAndExecute(*this, bus, opcode);
decodeAndExecute (cpu=..., bus=..., opcode=224 '\340') at /home/caidenmarley/gameboy/include/instructions.h:93
93	    switch(opcode){
1701	                uint8_t offset = bus.read(cpu.PC++);
Bus::read (this=0x7fffffff3910, address=8043) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::read (this=0x7fffffff3910, address=8043) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
22	    if(address < 0x8000){
24	        return cart.readByte(address);
Cartridge::readByte (this=0x7fffffff3860, address=8043) at /home/caidenmarley/gameboy/src/cartridge.cpp:118
118	    if(isMbc2){
135	    if(isMbc1){
159	    if(address < 0x8000){
160	        return romData.at(address);
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=8043) at /usr/include/c++/11/bits/stl_vector.h:1094
1094		_M_range_check(__n);
std::vector<unsigned char, std::allocator<unsigned char> >::_M_range_check (this=0x7fffffff38d0, __n=8043) at /usr/include/c++/11/bits/stl_vector.h:1072
1072		if (__n >= this->size())
std::vector<unsigned char, std::allocator<unsigned char> >::size (this=0x7fffffff38d0) at /usr/include/c++/11/bits/stl_vector.h:919
919	      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
std::vector<unsigned char, std::allocator<unsigned char> >::_M_range_check (this=0x7fffffff38d0, __n=8043) at /usr/include/c++/11/bits/stl_vector.h:1072
1072		if (__n >= this->size())
1077	      }
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=8043) at /usr/include/c++/11/bits/stl_vector.h:1095
1095		return (*this)[__n];
std::vector<unsigned char, std::allocator<unsigned char> >::operator[] (this=0x7fffffff38d0, __n=8043) at /usr/include/c++/11/bits/stl_vector.h:1046
1046		return *(this->_M_impl._M_start + __n);
1047	      }
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=8043) at /usr/include/c++/11/bits/stl_vector.h:1096
1096	      }
Cartridge::readByte (this=0x7fffffff3860, address=8043) at /home/caidenmarley/gameboy/src/cartridge.cpp:160
160	        return romData.at(address);
168	}
Bus::read (this=0x7fffffff3910, address=8043) at /home/caidenmarley/gameboy/src/bus.cpp:24
24	        return cart.readByte(address);
82	}
decodeAndExecute (cpu=..., bus=..., opcode=224 '\340') at /home/caidenmarley/gameboy/include/instructions.h:1702
1702	                if ((0xFF00u + offset) == 0xFF40 || (0xFF00u + offset) == 0xFF41) {
1711	                bus.write(0xFF00 + offset, cpu.A);
Bus::write (this=0x7fffffff3910, address=65351, byte=0 '\000') at /home/caidenmarley/gameboy/src/bus.cpp:85
85	    if(address == 0xFF00){
89	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::write (this=0x7fffffff3910, address=65351, byte=0 '\000') at /home/caidenmarley/gameboy/src/bus.cpp:89
89	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
94	    if(address < 0x8000){
97	    }else if(address < 0xA000){
100	    }else if(address < 0xC000){
103	    }else if(address < 0xE000){
106	    }else if(address < 0xFE00){
109	    }else if(address < 0xFEA0){
112	    }else if(address < 0xFF00){
114	    }else if(address < 0xFF04){
117	    }else if(address < 0xFF08){
120	    }else if(address >= 0xFF40 && address <= 0xFF4B){
122	        std::cout << "here2" << std::endl;
123	        if(address == 0xFF40){
126	        ppu.write(address, byte);
PPU::write (this=0x7fffffff3910, address=65351, byte=0 '\000') at /home/caidenmarley/gameboy/src/ppu.cpp:182
182	    if(address == 0xFF46){
194	    if(address >= 0x8000 && address <= 0x9FFF){
203	    if(address >= 0xFE00 && address <= 0xFE9F){
210	    if(address == 0xFF40){
214	    switch(address){
236	        case BGP_ADDRESS: BGP = byte; break;
243	}
Bus::write (this=0x7fffffff3910, address=65351, byte=0 '\000') at /home/caidenmarley/gameboy/src/bus.cpp:137
137	}
decodeAndExecute (cpu=..., bus=..., opcode=224 '\340') at /home/caidenmarley/gameboy/include/instructions.h:1712
1712	                return 3;
1886	}
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:58
58	    return decodeAndExecute(*this, bus, opcode);
59	}
main (argc=2, argv=0x7fffffffd6e8) at /home/caidenmarley/gameboy/main.cpp:124
124	            bus.step(m * 4, cpu);
Bus::step (this=0x7fffffff3910, tStates=12, cpu=...) at /home/caidenmarley/gameboy/src/bus.cpp:140
140	    timer.step(tStates, cpu);
Timer::step (this=0x7fffffffb4a0, tStates=12, cpu=...) at /home/caidenmarley/gameboy/src/timer.cpp:8
8	    divCounter += tStates;
9	    while(divCounter >= 256){
15	    if(TAC & 0x04){
30	}
Bus::step (this=0x7fffffff3910, tStates=12, cpu=...) at /home/caidenmarley/gameboy/src/bus.cpp:141
141	    ppu.step(tStates, cpu);
PPU::step (this=0x7fffffff3910, tStates=12, cpu=...) at /home/caidenmarley/gameboy/src/ppu.cpp:17
17	void PPU::step(int tStates, CPU& cpu){
18	    stepDma(tStates);
PPU::stepDma (this=0x7fffffff3910, cycles=12) at /home/caidenmarley/gameboy/include/ppu.h:151
151	        if(!oamDmaActive) return;
156	    }
PPU::step (this=0x7fffffff3910, tStates=12, cpu=...) at /home/caidenmarley/gameboy/src/ppu.cpp:20
20	    if(!(LCDC & 0x80)){
24	    dotCounter += tStates;
27	        uint8_t mode = STAT & 0x03;
28	        int needed = 0;
30	        switch(mode){
46	            case 1: needed = 4560; break;
50	        if (dotCounter < needed){
51	            break;
142	}
Bus::step (this=0x7fffffff3910, tStates=12, cpu=...) at /home/caidenmarley/gameboy/src/bus.cpp:143
143	}
main (argc=2, argv=0x7fffffffd6e8) at /home/caidenmarley/gameboy/main.cpp:122
122	        while (!bus.ppu.isFrameReady()) {
PPU::isFrameReady (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:46
46	        return frameReady;
47	    }
main (argc=2, argv=0x7fffffffd6e8) at /home/caidenmarley/gameboy/main.cpp:122
122	        while (!bus.ppu.isFrameReady()) {
123	            int m = cpu.step();
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:10
10	    if(imeEnabledNextStep){
16	    if(stopped){
26	    if(halted){
35	    uint8_t ieaValue = bus.read(INTERRUPT_ENABLE_ADDRESS);
Bus::read (this=0x7fffffff3910, address=65535) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::read (this=0x7fffffff3910, address=65535) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
22	    if(address < 0x8000){
25	    }else if(address < 0xA000){
28	    }else if(address < 0xC000){
31	    }else if(address < 0xE000){
34	    }else if(address < 0xFE00){
37	    }else if(address < 0xFEA0){
40	    }else if(address < 0xFF00){
43	    }else if(address == 0xFF00){
63	    }else if(address < 0xFF04){
66	    }else if(address < 0xFF08){
69	    }else if(address >= 0xFF40 && address <= 0xFF4B){
72	    }else if(address < 0xFF80){
75	    }else if(address < 0xFFFF){
80	        return ieReg;
82	}
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:36
36	    uint8_t ifaValue = bus.read(INTERRUPT_FLAG_ADDRESS);
Bus::read (this=0x7fffffff3910, address=65295) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::read (this=0x7fffffff3910, address=65295) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
22	    if(address < 0x8000){
25	    }else if(address < 0xA000){
28	    }else if(address < 0xC000){
31	    }else if(address < 0xE000){
34	    }else if(address < 0xFE00){
37	    }else if(address < 0xFEA0){
40	    }else if(address < 0xFF00){
43	    }else if(address == 0xFF00){
63	    }else if(address < 0xFF04){
66	    }else if(address < 0xFF08){
69	    }else if(address >= 0xFF40 && address <= 0xFF4B){
72	    }else if(address < 0xFF80){
74	        return ioRegs[address - 0xFF00];
82	}
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:37
37	    uint8_t interruptRequest = ieaValue & ifaValue;
38	    if(IME && interruptRequest){
57	    uint8_t opcode = bus.read(PC++);
Bus::read (this=0x7fffffff3910, address=8044) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::read (this=0x7fffffff3910, address=8044) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
22	    if(address < 0x8000){
24	        return cart.readByte(address);
Cartridge::readByte (this=0x7fffffff3860, address=8044) at /home/caidenmarley/gameboy/src/cartridge.cpp:118
118	    if(isMbc2){
135	    if(isMbc1){
159	    if(address < 0x8000){
160	        return romData.at(address);
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=8044) at /usr/include/c++/11/bits/stl_vector.h:1094
1094		_M_range_check(__n);
std::vector<unsigned char, std::allocator<unsigned char> >::_M_range_check (this=0x7fffffff38d0, __n=8044) at /usr/include/c++/11/bits/stl_vector.h:1072
1072		if (__n >= this->size())
std::vector<unsigned char, std::allocator<unsigned char> >::size (this=0x7fffffff38d0) at /usr/include/c++/11/bits/stl_vector.h:919
919	      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
std::vector<unsigned char, std::allocator<unsigned char> >::_M_range_check (this=0x7fffffff38d0, __n=8044) at /usr/include/c++/11/bits/stl_vector.h:1072
1072		if (__n >= this->size())
1077	      }
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=8044) at /usr/include/c++/11/bits/stl_vector.h:1095
1095		return (*this)[__n];
std::vector<unsigned char, std::allocator<unsigned char> >::operator[] (this=0x7fffffff38d0, __n=8044) at /usr/include/c++/11/bits/stl_vector.h:1046
1046		return *(this->_M_impl._M_start + __n);
1047	      }
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=8044) at /usr/include/c++/11/bits/stl_vector.h:1096
1096	      }
Cartridge::readByte (this=0x7fffffff3860, address=8044) at /home/caidenmarley/gameboy/src/cartridge.cpp:160
160	        return romData.at(address);
168	}
Bus::read (this=0x7fffffff3910, address=8044) at /home/caidenmarley/gameboy/src/bus.cpp:24
24	        return cart.readByte(address);
82	}
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:58
58	    return decodeAndExecute(*this, bus, opcode);
decodeAndExecute (cpu=..., bus=..., opcode=224 '\340') at /home/caidenmarley/gameboy/include/instructions.h:93
93	    switch(opcode){
1701	                uint8_t offset = bus.read(cpu.PC++);
Bus::read (this=0x7fffffff3910, address=8045) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
$9 = 0x91
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::read (this=0x7fffffff3910, address=8045) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
22	    if(address < 0x8000){
24	        return cart.readByte(address);
Cartridge::readByte (this=0x7fffffff3860, address=8045) at /home/caidenmarley/gameboy/src/cartridge.cpp:118
118	    if(isMbc2){
135	    if(isMbc1){
159	    if(address < 0x8000){
160	        return romData.at(address);
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=8045) at /usr/include/c++/11/bits/stl_vector.h:1094
1094		_M_range_check(__n);
std::vector<unsigned char, std::allocator<unsigned char> >::_M_range_check (this=0x7fffffff38d0, __n=8045) at /usr/include/c++/11/bits/stl_vector.h:1072
1072		if (__n >= this->size())
std::vector<unsigned char, std::allocator<unsigned char> >::size (this=0x7fffffff38d0) at /usr/include/c++/11/bits/stl_vector.h:919
919	      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
std::vector<unsigned char, std::allocator<unsigned char> >::_M_range_check (this=0x7fffffff38d0, __n=8045) at /usr/include/c++/11/bits/stl_vector.h:1072
1072		if (__n >= this->size())
1077	      }
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=8045) at /usr/include/c++/11/bits/stl_vector.h:1095
1095		return (*this)[__n];
std::vector<unsigned char, std::allocator<unsigned char> >::operator[] (this=0x7fffffff38d0, __n=8045) at /usr/include/c++/11/bits/stl_vector.h:1046
1046		return *(this->_M_impl._M_start + __n);
1047	      }
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=8045) at /usr/include/c++/11/bits/stl_vector.h:1096
1096	      }
Cartridge::readByte (this=0x7fffffff3860, address=8045) at /home/caidenmarley/gameboy/src/cartridge.cpp:160
160	        return romData.at(address);
168	}
Bus::read (this=0x7fffffff3910, address=8045) at /home/caidenmarley/gameboy/src/bus.cpp:24
24	        return cart.readByte(address);
82	}
decodeAndExecute (cpu=..., bus=..., opcode=224 '\340') at /home/caidenmarley/gameboy/include/instructions.h:1702
1702	                if ((0xFF00u + offset) == 0xFF40 || (0xFF00u + offset) == 0xFF41) {
1711	                bus.write(0xFF00 + offset, cpu.A);
Bus::write (this=0x7fffffff3910, address=65352, byte=0 '\000') at /home/caidenmarley/gameboy/src/bus.cpp:85
85	    if(address == 0xFF00){
89	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::write (this=0x7fffffff3910, address=65352, byte=0 '\000') at /home/caidenmarley/gameboy/src/bus.cpp:89
89	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
94	    if(address < 0x8000){
97	    }else if(address < 0xA000){
100	    }else if(address < 0xC000){
103	    }else if(address < 0xE000){
106	    }else if(address < 0xFE00){
109	    }else if(address < 0xFEA0){
112	    }else if(address < 0xFF00){
114	    }else if(address < 0xFF04){
117	    }else if(address < 0xFF08){
120	    }else if(address >= 0xFF40 && address <= 0xFF4B){
122	        std::cout << "here2" << std::endl;
123	        if(address == 0xFF40){
126	        ppu.write(address, byte);
PPU::write (this=0x7fffffff3910, address=65352, byte=0 '\000') at /home/caidenmarley/gameboy/src/ppu.cpp:182
182	    if(address == 0xFF46){
194	    if(address >= 0x8000 && address <= 0x9FFF){
203	    if(address >= 0xFE00 && address <= 0xFE9F){
210	    if(address == 0xFF40){
214	    switch(address){
237	        case OBP0_ADDRESS: OBP0 = byte; break;
243	}
Bus::write (this=0x7fffffff3910, address=65352, byte=0 '\000') at /home/caidenmarley/gameboy/src/bus.cpp:137
137	}
decodeAndExecute (cpu=..., bus=..., opcode=224 '\340') at /home/caidenmarley/gameboy/include/instructions.h:1712
1712	                return 3;
1886	}
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:58
58	    return decodeAndExecute(*this, bus, opcode);
59	}
main (argc=2, argv=0x7fffffffd6e8) at /home/caidenmarley/gameboy/main.cpp:124
124	            bus.step(m * 4, cpu);
Bus::step (this=0x7fffffff3910, tStates=12, cpu=...) at /home/caidenmarley/gameboy/src/bus.cpp:140
140	    timer.step(tStates, cpu);
Timer::step (this=0x7fffffffb4a0, tStates=12, cpu=...) at /home/caidenmarley/gameboy/src/timer.cpp:8
8	    divCounter += tStates;
9	    while(divCounter >= 256){
15	    if(TAC & 0x04){
30	}
Bus::step (this=0x7fffffff3910, tStates=12, cpu=...) at /home/caidenmarley/gameboy/src/bus.cpp:141
141	    ppu.step(tStates, cpu);
PPU::step (this=0x7fffffff3910, tStates=12, cpu=...) at /home/caidenmarley/gameboy/src/ppu.cpp:17
17	void PPU::step(int tStates, CPU& cpu){
18	    stepDma(tStates);
PPU::stepDma (this=0x7fffffff3910, cycles=12) at /home/caidenmarley/gameboy/include/ppu.h:151
151	        if(!oamDmaActive) return;
156	    }
PPU::step (this=0x7fffffff3910, tStates=12, cpu=...) at /home/caidenmarley/gameboy/src/ppu.cpp:20
20	    if(!(LCDC & 0x80)){
24	    dotCounter += tStates;
27	        uint8_t mode = STAT & 0x03;
28	        int needed = 0;
30	        switch(mode){
46	            case 1: needed = 4560; break;
50	        if (dotCounter < needed){
51	            break;
142	}
Bus::step (this=0x7fffffff3910, tStates=12, cpu=...) at /home/caidenmarley/gameboy/src/bus.cpp:143
143	}
main (argc=2, argv=0x7fffffffd6e8) at /home/caidenmarley/gameboy/main.cpp:122
122	        while (!bus.ppu.isFrameReady()) {
PPU::isFrameReady (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:46
46	        return frameReady;
47	    }
main (argc=2, argv=0x7fffffffd6e8) at /home/caidenmarley/gameboy/main.cpp:122
122	        while (!bus.ppu.isFrameReady()) {
123	            int m = cpu.step();
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:10
10	    if(imeEnabledNextStep){
16	    if(stopped){
26	    if(halted){
35	    uint8_t ieaValue = bus.read(INTERRUPT_ENABLE_ADDRESS);
Bus::read (this=0x7fffffff3910, address=65535) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::read (this=0x7fffffff3910, address=65535) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
22	    if(address < 0x8000){
25	    }else if(address < 0xA000){
28	    }else if(address < 0xC000){
31	    }else if(address < 0xE000){
34	    }else if(address < 0xFE00){
37	    }else if(address < 0xFEA0){
40	    }else if(address < 0xFF00){
43	    }else if(address == 0xFF00){
63	    }else if(address < 0xFF04){
66	    }else if(address < 0xFF08){
69	    }else if(address >= 0xFF40 && address <= 0xFF4B){
72	    }else if(address < 0xFF80){
75	    }else if(address < 0xFFFF){
80	        return ieReg;
82	}
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:36
36	    uint8_t ifaValue = bus.read(INTERRUPT_FLAG_ADDRESS);
Bus::read (this=0x7fffffff3910, address=65295) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::read (this=0x7fffffff3910, address=65295) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
22	    if(address < 0x8000){
25	    }else if(address < 0xA000){
28	    }else if(address < 0xC000){
31	    }else if(address < 0xE000){
34	    }else if(address < 0xFE00){
37	    }else if(address < 0xFEA0){
40	    }else if(address < 0xFF00){
43	    }else if(address == 0xFF00){
63	    }else if(address < 0xFF04){
66	    }else if(address < 0xFF08){
69	    }else if(address >= 0xFF40 && address <= 0xFF4B){
72	    }else if(address < 0xFF80){
74	        return ioRegs[address - 0xFF00];
82	}
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:37
37	    uint8_t interruptRequest = ieaValue & ifaValue;
38	    if(IME && interruptRequest){
57	    uint8_t opcode = bus.read(PC++);
Bus::read (this=0x7fffffff3910, address=8046) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::read (this=0x7fffffff3910, address=8046) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
22	    if(address < 0x8000){
24	        return cart.readByte(address);
Cartridge::readByte (this=0x7fffffff3860, address=8046) at /home/caidenmarley/gameboy/src/cartridge.cpp:118
118	    if(isMbc2){
135	    if(isMbc1){
159	    if(address < 0x8000){
160	        return romData.at(address);
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=8046) at /usr/include/c++/11/bits/stl_vector.h:1094
1094		_M_range_check(__n);
std::vector<unsigned char, std::allocator<unsigned char> >::_M_range_check (this=0x7fffffff38d0, __n=8046) at /usr/include/c++/11/bits/stl_vector.h:1072
1072		if (__n >= this->size())
std::vector<unsigned char, std::allocator<unsigned char> >::size (this=0x7fffffff38d0) at /usr/include/c++/11/bits/stl_vector.h:919
919	      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
std::vector<unsigned char, std::allocator<unsigned char> >::_M_range_check (this=0x7fffffff38d0, __n=8046) at /usr/include/c++/11/bits/stl_vector.h:1072
1072		if (__n >= this->size())
1077	      }
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=8046) at /usr/include/c++/11/bits/stl_vector.h:1095
1095		return (*this)[__n];
std::vector<unsigned char, std::allocator<unsigned char> >::operator[] (this=0x7fffffff38d0, __n=8046) at /usr/include/c++/11/bits/stl_vector.h:1046
1046		return *(this->_M_impl._M_start + __n);
1047	      }
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=8046) at /usr/include/c++/11/bits/stl_vector.h:1096
1096	      }
Cartridge::readByte (this=0x7fffffff3860, address=8046) at /home/caidenmarley/gameboy/src/cartridge.cpp:160
160	        return romData.at(address);
168	}
Bus::read (this=0x7fffffff3910, address=8046) at /home/caidenmarley/gameboy/src/bus.cpp:24
24	        return cart.readByte(address);
82	}
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:58
58	    return decodeAndExecute(*this, bus, opcode);
decodeAndExecute (cpu=..., bus=..., opcode=224 '\340') at /home/caidenmarley/gameboy/include/instructions.h:93
93	    switch(opcode){
1701	                uint8_t offset = bus.read(cpu.PC++);
Bus::read (this=0x7fffffff3910, address=8047) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::read (this=0x7fffffff3910, address=8047) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
22	    if(address < 0x8000){
24	        return cart.readByte(address);
Cartridge::readByte (this=0x7fffffff3860, address=8047) at /home/caidenmarley/gameboy/src/cartridge.cpp:118
118	    if(isMbc2){
135	    if(isMbc1){
159	    if(address < 0x8000){
160	        return romData.at(address);
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=8047) at /usr/include/c++/11/bits/stl_vector.h:1094
1094		_M_range_check(__n);
std::vector<unsigned char, std::allocator<unsigned char> >::_M_range_check (this=0x7fffffff38d0, __n=8047) at /usr/include/c++/11/bits/stl_vector.h:1072
1072		if (__n >= this->size())
std::vector<unsigned char, std::allocator<unsigned char> >::size (this=0x7fffffff38d0) at /usr/include/c++/11/bits/stl_vector.h:919
919	      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
std::vector<unsigned char, std::allocator<unsigned char> >::_M_range_check (this=0x7fffffff38d0, __n=8047) at /usr/include/c++/11/bits/stl_vector.h:1072
1072		if (__n >= this->size())
1077	      }
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=8047) at /usr/include/c++/11/bits/stl_vector.h:1095
1095		return (*this)[__n];
std::vector<unsigned char, std::allocator<unsigned char> >::operator[] (this=0x7fffffff38d0, __n=8047) at /usr/include/c++/11/bits/stl_vector.h:1046
1046		return *(this->_M_impl._M_start + __n);
1047	      }
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=8047) at /usr/include/c++/11/bits/stl_vector.h:1096
1096	      }
Cartridge::readByte (this=0x7fffffff3860, address=8047) at /home/caidenmarley/gameboy/src/cartridge.cpp:160
160	        return romData.at(address);
168	}
Bus::read (this=0x7fffffff3910, address=8047) at /home/caidenmarley/gameboy/src/bus.cpp:24
24	        return cart.readByte(address);
82	}
decodeAndExecute (cpu=..., bus=..., opcode=224 '\340') at /home/caidenmarley/gameboy/include/instructions.h:1702
1702	                if ((0xFF00u + offset) == 0xFF40 || (0xFF00u + offset) == 0xFF41) {
1711	                bus.write(0xFF00 + offset, cpu.A);
Bus::write (this=0x7fffffff3910, address=65353, byte=0 '\000') at /home/caidenmarley/gameboy/src/bus.cpp:85
85	    if(address == 0xFF00){
89	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::write (this=0x7fffffff3910, address=65353, byte=0 '\000') at /home/caidenmarley/gameboy/src/bus.cpp:89
89	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
94	    if(address < 0x8000){
97	    }else if(address < 0xA000){
100	    }else if(address < 0xC000){
103	    }else if(address < 0xE000){
106	    }else if(address < 0xFE00){
109	    }else if(address < 0xFEA0){
112	    }else if(address < 0xFF00){
114	    }else if(address < 0xFF04){
117	    }else if(address < 0xFF08){
120	    }else if(address >= 0xFF40 && address <= 0xFF4B){
122	        std::cout << "here2" << std::endl;
123	        if(address == 0xFF40){
126	        ppu.write(address, byte);
PPU::write (this=0x7fffffff3910, address=65353, byte=0 '\000') at /home/caidenmarley/gameboy/src/ppu.cpp:182
182	    if(address == 0xFF46){
194	    if(address >= 0x8000 && address <= 0x9FFF){
203	    if(address >= 0xFE00 && address <= 0xFE9F){
210	    if(address == 0xFF40){
214	    switch(address){
238	        case OBP1_ADDRESS: OBP1 = byte; break;
243	}
Bus::write (this=0x7fffffff3910, address=65353, byte=0 '\000') at /home/caidenmarley/gameboy/src/bus.cpp:137
137	}
decodeAndExecute (cpu=..., bus=..., opcode=224 '\340') at /home/caidenmarley/gameboy/include/instructions.h:1712
1712	                return 3;
1886	}
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:58
58	    return decodeAndExecute(*this, bus, opcode);
59	}
main (argc=2, argv=0x7fffffffd6e8) at /home/caidenmarley/gameboy/main.cpp:124
124	            bus.step(m * 4, cpu);
Bus::step (this=0x7fffffff3910, tStates=12, cpu=...) at /home/caidenmarley/gameboy/src/bus.cpp:140
140	    timer.step(tStates, cpu);
Timer::step (this=0x7fffffffb4a0, tStates=12, cpu=...) at /home/caidenmarley/gameboy/src/timer.cpp:8
8	    divCounter += tStates;
9	    while(divCounter >= 256){
15	    if(TAC & 0x04){
30	}
Bus::step (this=0x7fffffff3910, tStates=12, cpu=...) at /home/caidenmarley/gameboy/src/bus.cpp:141
141	    ppu.step(tStates, cpu);
PPU::step (this=0x7fffffff3910, tStates=12, cpu=...) at /home/caidenmarley/gameboy/src/ppu.cpp:17
17	void PPU::step(int tStates, CPU& cpu){
18	    stepDma(tStates);
PPU::stepDma (this=0x7fffffff3910, cycles=12) at /home/caidenmarley/gameboy/include/ppu.h:151
151	        if(!oamDmaActive) return;
156	    }
PPU::step (this=0x7fffffff3910, tStates=12, cpu=...) at /home/caidenmarley/gameboy/src/ppu.cpp:20
20	    if(!(LCDC & 0x80)){
24	    dotCounter += tStates;
27	        uint8_t mode = STAT & 0x03;
28	        int needed = 0;
30	        switch(mode){
46	            case 1: needed = 4560; break;
50	        if (dotCounter < needed){
51	            break;
142	}
Bus::step (this=0x7fffffff3910, tStates=12, cpu=...) at /home/caidenmarley/gameboy/src/bus.cpp:143
143	}
main (argc=2, argv=0x7fffffffd6e8) at /home/caidenmarley/gameboy/main.cpp:122
122	        while (!bus.ppu.isFrameReady()) {
PPU::isFrameReady (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:46
46	        return frameReady;
47	    }
main (argc=2, argv=0x7fffffffd6e8) at /home/caidenmarley/gameboy/main.cpp:122
122	        while (!bus.ppu.isFrameReady()) {
123	            int m = cpu.step();
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:10
10	    if(imeEnabledNextStep){
16	    if(stopped){
26	    if(halted){
35	    uint8_t ieaValue = bus.read(INTERRUPT_ENABLE_ADDRESS);
Bus::read (this=0x7fffffff3910, address=65535) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::read (this=0x7fffffff3910, address=65535) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
22	    if(address < 0x8000){
25	    }else if(address < 0xA000){
28	    }else if(address < 0xC000){
31	    }else if(address < 0xE000){
34	    }else if(address < 0xFE00){
37	    }else if(address < 0xFEA0){
40	    }else if(address < 0xFF00){
43	    }else if(address == 0xFF00){
63	    }else if(address < 0xFF04){
66	    }else if(address < 0xFF08){
69	    }else if(address >= 0xFF40 && address <= 0xFF4B){
72	    }else if(address < 0xFF80){
75	    }else if(address < 0xFFFF){
80	        return ieReg;
82	}
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:36
36	    uint8_t ifaValue = bus.read(INTERRUPT_FLAG_ADDRESS);
Bus::read (this=0x7fffffff3910, address=65295) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::read (this=0x7fffffff3910, address=65295) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
22	    if(address < 0x8000){
25	    }else if(address < 0xA000){
28	    }else if(address < 0xC000){
31	    }else if(address < 0xE000){
34	    }else if(address < 0xFE00){
37	    }else if(address < 0xFEA0){
40	    }else if(address < 0xFF00){
43	    }else if(address == 0xFF00){
63	    }else if(address < 0xFF04){
66	    }else if(address < 0xFF08){
69	    }else if(address >= 0xFF40 && address <= 0xFF4B){
72	    }else if(address < 0xFF80){
74	        return ioRegs[address - 0xFF00];
82	}
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:37
37	    uint8_t interruptRequest = ieaValue & ifaValue;
38	    if(IME && interruptRequest){
57	    uint8_t opcode = bus.read(PC++);
Bus::read (this=0x7fffffff3910, address=8048) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::read (this=0x7fffffff3910, address=8048) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
22	    if(address < 0x8000){
24	        return cart.readByte(address);
Cartridge::readByte (this=0x7fffffff3860, address=8048) at /home/caidenmarley/gameboy/src/cartridge.cpp:118
118	    if(isMbc2){
135	    if(isMbc1){
159	    if(address < 0x8000){
160	        return romData.at(address);
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=8048) at /usr/include/c++/11/bits/stl_vector.h:1094
1094		_M_range_check(__n);
std::vector<unsigned char, std::allocator<unsigned char> >::_M_range_check (this=0x7fffffff38d0, __n=8048) at /usr/include/c++/11/bits/stl_vector.h:1072
1072		if (__n >= this->size())
std::vector<unsigned char, std::allocator<unsigned char> >::size (this=0x7fffffff38d0) at /usr/include/c++/11/bits/stl_vector.h:919
919	      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
std::vector<unsigned char, std::allocator<unsigned char> >::_M_range_check (this=0x7fffffff38d0, __n=8048) at /usr/include/c++/11/bits/stl_vector.h:1072
1072		if (__n >= this->size())
1077	      }
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=8048) at /usr/include/c++/11/bits/stl_vector.h:1095
1095		return (*this)[__n];
std::vector<unsigned char, std::allocator<unsigned char> >::operator[] (this=0x7fffffff38d0, __n=8048) at /usr/include/c++/11/bits/stl_vector.h:1046
1046		return *(this->_M_impl._M_start + __n);
1047	      }
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=8048) at /usr/include/c++/11/bits/stl_vector.h:1096
1096	      }
Cartridge::readByte (this=0x7fffffff3860, address=8048) at /home/caidenmarley/gameboy/src/cartridge.cpp:160
160	        return romData.at(address);
168	}
Bus::read (this=0x7fffffff3910, address=8048) at /home/caidenmarley/gameboy/src/bus.cpp:24
24	        return cart.readByte(address);
82	}
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:58
58	    return decodeAndExecute(*this, bus, opcode);
decodeAndExecute (cpu=..., bus=..., opcode=62 '>') at /home/caidenmarley/gameboy/include/instructions.h:93
93	    switch(opcode){
653	                cpu.A = bus.read(cpu.PC++);
Bus::read (this=0x7fffffff3910, address=8049) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::read (this=0x7fffffff3910, address=8049) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
22	    if(address < 0x8000){
24	        return cart.readByte(address);
Cartridge::readByte (this=0x7fffffff3860, address=8049) at /home/caidenmarley/gameboy/src/cartridge.cpp:118
118	    if(isMbc2){
135	    if(isMbc1){
159	    if(address < 0x8000){
160	        return romData.at(address);
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=8049) at /usr/include/c++/11/bits/stl_vector.h:1094
1094		_M_range_check(__n);
std::vector<unsigned char, std::allocator<unsigned char> >::_M_range_check (this=0x7fffffff38d0, __n=8049) at /usr/include/c++/11/bits/stl_vector.h:1072
1072		if (__n >= this->size())
std::vector<unsigned char, std::allocator<unsigned char> >::size (this=0x7fffffff38d0) at /usr/include/c++/11/bits/stl_vector.h:919
919	      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
std::vector<unsigned char, std::allocator<unsigned char> >::_M_range_check (this=0x7fffffff38d0, __n=8049) at /usr/include/c++/11/bits/stl_vector.h:1072
1072		if (__n >= this->size())
1077	      }
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=8049) at /usr/include/c++/11/bits/stl_vector.h:1095
1095		return (*this)[__n];
std::vector<unsigned char, std::allocator<unsigned char> >::operator[] (this=0x7fffffff38d0, __n=8049) at /usr/include/c++/11/bits/stl_vector.h:1046
1046		return *(this->_M_impl._M_start + __n);
1047	      }
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=8049) at /usr/include/c++/11/bits/stl_vector.h:1096
1096	      }
Cartridge::readByte (this=0x7fffffff3860, address=8049) at /home/caidenmarley/gameboy/src/cartridge.cpp:160
160	        return romData.at(address);
168	}
Bus::read (this=0x7fffffff3910, address=8049) at /home/caidenmarley/gameboy/src/bus.cpp:24
24	        return cart.readByte(address);
82	}
decodeAndExecute (cpu=..., bus=..., opcode=62 '>') at /home/caidenmarley/gameboy/include/instructions.h:653
653	                cpu.A = bus.read(cpu.PC++);
654	                return 2;
1886	}
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:58
58	    return decodeAndExecute(*this, bus, opcode);
59	}
main (argc=2, argv=0x7fffffffd6e8) at /home/caidenmarley/gameboy/main.cpp:124
124	            bus.step(m * 4, cpu);
Bus::step (this=0x7fffffff3910, tStates=8, cpu=...) at /home/caidenmarley/gameboy/src/bus.cpp:140
140	    timer.step(tStates, cpu);
Timer::step (this=0x7fffffffb4a0, tStates=8, cpu=...) at /home/caidenmarley/gameboy/src/timer.cpp:8
8	    divCounter += tStates;
9	    while(divCounter >= 256){
10	        DIV = uint8_t(DIV + 1); // automatically wraps round 255+1-> 0
11	        divCounter -= 256; // remove the 256 that it wrapped around
9	    while(divCounter >= 256){
15	    if(TAC & 0x04){
30	}
Bus::step (this=0x7fffffff3910, tStates=8, cpu=...) at /home/caidenmarley/gameboy/src/bus.cpp:141
141	    ppu.step(tStates, cpu);
PPU::step (this=0x7fffffff3910, tStates=8, cpu=...) at /home/caidenmarley/gameboy/src/ppu.cpp:17
17	void PPU::step(int tStates, CPU& cpu){
18	    stepDma(tStates);
PPU::stepDma (this=0x7fffffff3910, cycles=8) at /home/caidenmarley/gameboy/include/ppu.h:151
151	        if(!oamDmaActive) return;
156	    }
PPU::step (this=0x7fffffff3910, tStates=8, cpu=...) at /home/caidenmarley/gameboy/src/ppu.cpp:20
20	    if(!(LCDC & 0x80)){
24	    dotCounter += tStates;
27	        uint8_t mode = STAT & 0x03;
28	        int needed = 0;
30	        switch(mode){
46	            case 1: needed = 4560; break;
50	        if (dotCounter < needed){
51	            break;
142	}
Bus::step (this=0x7fffffff3910, tStates=8, cpu=...) at /home/caidenmarley/gameboy/src/bus.cpp:143
143	}
main (argc=2, argv=0x7fffffffd6e8) at /home/caidenmarley/gameboy/main.cpp:122
122	        while (!bus.ppu.isFrameReady()) {
PPU::isFrameReady (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:46
46	        return frameReady;
47	    }
main (argc=2, argv=0x7fffffffd6e8) at /home/caidenmarley/gameboy/main.cpp:122
122	        while (!bus.ppu.isFrameReady()) {
123	            int m = cpu.step();
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:10
10	    if(imeEnabledNextStep){
16	    if(stopped){
26	    if(halted){
35	    uint8_t ieaValue = bus.read(INTERRUPT_ENABLE_ADDRESS);
Bus::read (this=0x7fffffff3910, address=65535) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::read (this=0x7fffffff3910, address=65535) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
22	    if(address < 0x8000){
25	    }else if(address < 0xA000){
28	    }else if(address < 0xC000){
31	    }else if(address < 0xE000){
34	    }else if(address < 0xFE00){
37	    }else if(address < 0xFEA0){
40	    }else if(address < 0xFF00){
43	    }else if(address == 0xFF00){
63	    }else if(address < 0xFF04){
66	    }else if(address < 0xFF08){
69	    }else if(address >= 0xFF40 && address <= 0xFF4B){
72	    }else if(address < 0xFF80){
75	    }else if(address < 0xFFFF){
80	        return ieReg;
82	}
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:36
36	    uint8_t ifaValue = bus.read(INTERRUPT_FLAG_ADDRESS);
Bus::read (this=0x7fffffff3910, address=65295) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::read (this=0x7fffffff3910, address=65295) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
22	    if(address < 0x8000){
25	    }else if(address < 0xA000){
28	    }else if(address < 0xC000){
31	    }else if(address < 0xE000){
34	    }else if(address < 0xFE00){
37	    }else if(address < 0xFEA0){
40	    }else if(address < 0xFF00){
43	    }else if(address == 0xFF00){
63	    }else if(address < 0xFF04){
66	    }else if(address < 0xFF08){
69	    }else if(address >= 0xFF40 && address <= 0xFF4B){
72	    }else if(address < 0xFF80){
74	        return ioRegs[address - 0xFF00];
82	}
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:37
37	    uint8_t interruptRequest = ieaValue & ifaValue;
38	    if(IME && interruptRequest){
57	    uint8_t opcode = bus.read(PC++);
Bus::read (this=0x7fffffff3910, address=8050) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::read (this=0x7fffffff3910, address=8050) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
22	    if(address < 0x8000){
24	        return cart.readByte(address);
Cartridge::readByte (this=0x7fffffff3860, address=8050) at /home/caidenmarley/gameboy/src/cartridge.cpp:118
118	    if(isMbc2){
135	    if(isMbc1){
159	    if(address < 0x8000){
160	        return romData.at(address);
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=8050) at /usr/include/c++/11/bits/stl_vector.h:1094
1094		_M_range_check(__n);
std::vector<unsigned char, std::allocator<unsigned char> >::_M_range_check (this=0x7fffffff38d0, __n=8050) at /usr/include/c++/11/bits/stl_vector.h:1072
1072		if (__n >= this->size())
std::vector<unsigned char, std::allocator<unsigned char> >::size (this=0x7fffffff38d0) at /usr/include/c++/11/bits/stl_vector.h:919
919	      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
std::vector<unsigned char, std::allocator<unsigned char> >::_M_range_check (this=0x7fffffff38d0, __n=8050) at /usr/include/c++/11/bits/stl_vector.h:1072
1072		if (__n >= this->size())
1077	      }
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=8050) at /usr/include/c++/11/bits/stl_vector.h:1095
1095		return (*this)[__n];
std::vector<unsigned char, std::allocator<unsigned char> >::operator[] (this=0x7fffffff38d0, __n=8050) at /usr/include/c++/11/bits/stl_vector.h:1046
1046		return *(this->_M_impl._M_start + __n);
1047	      }
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=8050) at /usr/include/c++/11/bits/stl_vector.h:1096
1096	      }
Cartridge::readByte (this=0x7fffffff3860, address=8050) at /home/caidenmarley/gameboy/src/cartridge.cpp:160
160	        return romData.at(address);
168	}
Bus::read (this=0x7fffffff3910, address=8050) at /home/caidenmarley/gameboy/src/bus.cpp:24
24	        return cart.readByte(address);
82	}
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:58
58	    return decodeAndExecute(*this, bus, opcode);
decodeAndExecute (cpu=..., bus=..., opcode=224 '\340') at /home/caidenmarley/gameboy/include/instructions.h:93
93	    switch(opcode){
1701	                uint8_t offset = bus.read(cpu.PC++);
Bus::read (this=0x7fffffff3910, address=8051) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::read (this=0x7fffffff3910, address=8051) at /home/caidenmarley/gameboy/src/bus.cpp:17
17	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
22	    if(address < 0x8000){
24	        return cart.readByte(address);
Cartridge::readByte (this=0x7fffffff3860, address=8051) at /home/caidenmarley/gameboy/src/cartridge.cpp:118
118	    if(isMbc2){
135	    if(isMbc1){
159	    if(address < 0x8000){
160	        return romData.at(address);
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=8051) at /usr/include/c++/11/bits/stl_vector.h:1094
1094		_M_range_check(__n);
std::vector<unsigned char, std::allocator<unsigned char> >::_M_range_check (this=0x7fffffff38d0, __n=8051) at /usr/include/c++/11/bits/stl_vector.h:1072
1072		if (__n >= this->size())
std::vector<unsigned char, std::allocator<unsigned char> >::size (this=0x7fffffff38d0) at /usr/include/c++/11/bits/stl_vector.h:919
919	      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
std::vector<unsigned char, std::allocator<unsigned char> >::_M_range_check (this=0x7fffffff38d0, __n=8051) at /usr/include/c++/11/bits/stl_vector.h:1072
1072		if (__n >= this->size())
1077	      }
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=8051) at /usr/include/c++/11/bits/stl_vector.h:1095
1095		return (*this)[__n];
std::vector<unsigned char, std::allocator<unsigned char> >::operator[] (this=0x7fffffff38d0, __n=8051) at /usr/include/c++/11/bits/stl_vector.h:1046
1046		return *(this->_M_impl._M_start + __n);
1047	      }
std::vector<unsigned char, std::allocator<unsigned char> >::at (this=0x7fffffff38d0, __n=8051) at /usr/include/c++/11/bits/stl_vector.h:1096
1096	      }
Cartridge::readByte (this=0x7fffffff3860, address=8051) at /home/caidenmarley/gameboy/src/cartridge.cpp:160
160	        return romData.at(address);
168	}
Bus::read (this=0x7fffffff3910, address=8051) at /home/caidenmarley/gameboy/src/bus.cpp:24
24	        return cart.readByte(address);
82	}
decodeAndExecute (cpu=..., bus=..., opcode=224 '\340') at /home/caidenmarley/gameboy/include/instructions.h:1702
1702	                if ((0xFF00u + offset) == 0xFF40 || (0xFF00u + offset) == 0xFF41) {
1704	                    << ">>> [CPU] E0 LDH write to " 
1705	                    << std::hex << std::showbase << (0xFF00u + offset) 
1706	                    << " = 0x" << std::hex << int(cpu.A)
1707	                    << " @ ROM_PC=0x" << std::hex << cpu.PC 
1708	                    << "\n";
1709	                    std::cout << "cpu@a" << std::hex << int(cpu.A) << std::endl;
1711	                bus.write(0xFF00 + offset, cpu.A);
Bus::write (this=0x7fffffff3910, address=65344, byte=128 '\200') at /home/caidenmarley/gameboy/src/bus.cpp:85
85	    if(address == 0xFF00){
89	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
PPU::isOamDmaActive (this=0x7fffffff3910) at /home/caidenmarley/gameboy/include/ppu.h:50
50	        return oamDmaActive;
51	    }
Bus::write (this=0x7fffffff3910, address=65344, byte=128 '\200') at /home/caidenmarley/gameboy/src/bus.cpp:89
89	    if(ppu.isOamDmaActive() && (address < 0xFF80 || address > 0xFFFE)){
94	    if(address < 0x8000){
97	    }else if(address < 0xA000){
100	    }else if(address < 0xC000){
103	    }else if(address < 0xE000){
106	    }else if(address < 0xFE00){
109	    }else if(address < 0xFEA0){
112	    }else if(address < 0xFF00){
114	    }else if(address < 0xFF04){
117	    }else if(address < 0xFF08){
120	    }else if(address >= 0xFF40 && address <= 0xFF4B){
122	        std::cout << "here2" << std::endl;
123	        if(address == 0xFF40){
124	            std::cout<< "here3" << std::endl;
126	        ppu.write(address, byte);
PPU::write (this=0x7fffffff3910, address=65344, byte=128 '\200') at /home/caidenmarley/gameboy/src/ppu.cpp:182
182	    if(address == 0xFF46){
194	    if(address >= 0x8000 && address <= 0x9FFF){
203	    if(address >= 0xFE00 && address <= 0xFE9F){
210	    if(address == 0xFF40){
211	        std::cout<<"temp" <<std::endl;
214	    switch(address){
216	            std::cout<<"LCDCHere"<<std::endl;
217	            bool wasOn = LCDC & 0x80;
218	            LCDC = byte;
219	            std::cout << "BYTE VAL" << std::hex << int(byte) << std::endl;
220	            bool isOn = LCDC & 0x80;
221	            std::cout<<"wasON" << std::boolalpha << wasOn << std::endl;
222	            std::cout<<"isON" << std::boolalpha << isOn << std::endl;
223	            if(wasOn && !isOn){
226	            }else if(!wasOn && isOn){
230	        } break;
243	}
Bus::write (this=0x7fffffff3910, address=65344, byte=128 '\200') at /home/caidenmarley/gameboy/src/bus.cpp:137
137	}
decodeAndExecute (cpu=..., bus=..., opcode=224 '\340') at /home/caidenmarley/gameboy/include/instructions.h:1712
1712	                return 3;
1886	}
CPU::step (this=0x7fffffff37c0) at /home/caidenmarley/gameboy/src/cpu.cpp:58
58	    return decodeAndExecute(*this, bus, opcode);
59	}
main (argc=2, argv=0x7fffffffd6e8) at /home/caidenmarley/gameboy/main.cpp:124
124	            bus.step(m * 4, cpu);
Bus::step (this=0x7fffffff3910, tStates=12, cpu=...) at /home/caidenmarley/gameboy/src/bus.cpp:140
140	    timer.step(tStates, cpu);
Timer::step (this=0x7fffffffb4a0, tStates=12, cpu=...) at /home/caidenmarley/gameboy/src/timer.cpp:8
8	    divCounter += tStates;
9	    while(divCounter >= 256){
15	    if(TAC & 0x04){
30	}
Bus::step (this=0x7fffffff3910, tStates=12, cpu=...) at /home/caidenmarley/gameboy/src/bus.cpp:141
141	    ppu.step(tStates, cpu);
PPU::step (this=0x7fffffff3910, tStates=12, cpu=...) at /home/caidenmarley/gameboy/src/ppu.cpp:17
17	void PPU::step(int tStates, CPU& cpu){
18	    stepDma(tStates);
PPU::stepDma (this=0x7fffffff3910, cycles=12) at /home/caidenmarley/gameboy/include/ppu.h:151
151	        if(!oamDmaActive) return;
156	    }
PPU::step (this=0x7fffffff3910, tStates=12, cpu=...) at /home/caidenmarley/gameboy/src/ppu.cpp:20
20	    if(!(LCDC & 0x80)){
24	    dotCounter += tStates;
$10 = 0x80
#1  0x000055555555f5f2 in Bus::step (this=0x7fffffff3910, tStates=12, cpu=...) at /home/caidenmarley/gameboy/src/bus.cpp:141
141	    ppu.step(tStates, cpu);
#2  0x000055555555c35f in main (argc=2, argv=0x7fffffffd6e8) at /home/caidenmarley/gameboy/main.cpp:124
124	            bus.step(m * 4, cpu);
Initial frame selected; you cannot go up.
27	        uint8_t mode = STAT & 0x03;
#0  PPU::step (this=0x7fffffff3910, tStates=12, cpu=...) at /home/caidenmarley/gameboy/src/ppu.cpp:27
#1  0x000055555555f5f2 in Bus::step (this=0x7fffffff3910, tStates=12, cpu=...) at /home/caidenmarley/gameboy/src/bus.cpp:141
#2  0x000055555555c35f in main (argc=2, argv=0x7fffffffd6e8) at /home/caidenmarley/gameboy/main.cpp:124
